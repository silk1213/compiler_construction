//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   PDefs    ********************/
PDefs::PDefs(ListDef *p1)
{
  listdef_ = p1;

}

PDefs::PDefs(const PDefs & other)
{
  listdef_ = other.listdef_->clone();

}

PDefs &PDefs::operator=(const PDefs & other)
{
  PDefs tmp(other);
  swap(tmp);
  return *this;
}

void PDefs::swap(PDefs & other)
{
  std::swap(listdef_, other.listdef_);

}

PDefs::~PDefs()
{
  delete(listdef_);

}

void PDefs::accept(Visitor *v)
{
  v->visitPDefs(this);
}

PDefs *PDefs::clone() const
{
  return new PDefs(*this);
}



/********************   DefinitionFunction    ********************/
DefinitionFunction::DefinitionFunction(Type *p1, Id p2, ListArg *p3, ListStm *p4)
{
  type_ = p1;
  id_ = p2;
  listarg_ = p3;
  liststm_ = p4;

}

DefinitionFunction::DefinitionFunction(const DefinitionFunction & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;
  listarg_ = other.listarg_->clone();
  liststm_ = other.liststm_->clone();

}

DefinitionFunction &DefinitionFunction::operator=(const DefinitionFunction & other)
{
  DefinitionFunction tmp(other);
  swap(tmp);
  return *this;
}

void DefinitionFunction::swap(DefinitionFunction & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);
  std::swap(listarg_, other.listarg_);
  std::swap(liststm_, other.liststm_);

}

DefinitionFunction::~DefinitionFunction()
{
  delete(type_);
  delete(listarg_);
  delete(liststm_);

}

void DefinitionFunction::accept(Visitor *v)
{
  v->visitDefinitionFunction(this);
}

DefinitionFunction *DefinitionFunction::clone() const
{
  return new DefinitionFunction(*this);
}



/********************   DefinitionUsing    ********************/
DefinitionUsing::DefinitionUsing(Exp *p1)
{
  exp_ = p1;

}

DefinitionUsing::DefinitionUsing(const DefinitionUsing & other)
{
  exp_ = other.exp_->clone();

}

DefinitionUsing &DefinitionUsing::operator=(const DefinitionUsing & other)
{
  DefinitionUsing tmp(other);
  swap(tmp);
  return *this;
}

void DefinitionUsing::swap(DefinitionUsing & other)
{
  std::swap(exp_, other.exp_);

}

DefinitionUsing::~DefinitionUsing()
{
  delete(exp_);

}

void DefinitionUsing::accept(Visitor *v)
{
  v->visitDefinitionUsing(this);
}

DefinitionUsing *DefinitionUsing::clone() const
{
  return new DefinitionUsing(*this);
}



/********************   StatementDeclaration    ********************/
StatementDeclaration::StatementDeclaration(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

StatementDeclaration::StatementDeclaration(const StatementDeclaration & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

StatementDeclaration &StatementDeclaration::operator=(const StatementDeclaration & other)
{
  StatementDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void StatementDeclaration::swap(StatementDeclaration & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

StatementDeclaration::~StatementDeclaration()
{
  delete(type_);

}

void StatementDeclaration::accept(Visitor *v)
{
  v->visitStatementDeclaration(this);
}

StatementDeclaration *StatementDeclaration::clone() const
{
  return new StatementDeclaration(*this);
}



/********************   StatementDeclarations    ********************/
StatementDeclarations::StatementDeclarations(Type *p1, Id p2, ListId *p3)
{
  type_ = p1;
  id_ = p2;
  listid_ = p3;

}

StatementDeclarations::StatementDeclarations(const StatementDeclarations & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;
  listid_ = other.listid_->clone();

}

StatementDeclarations &StatementDeclarations::operator=(const StatementDeclarations & other)
{
  StatementDeclarations tmp(other);
  swap(tmp);
  return *this;
}

void StatementDeclarations::swap(StatementDeclarations & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);
  std::swap(listid_, other.listid_);

}

StatementDeclarations::~StatementDeclarations()
{
  delete(type_);
  delete(listid_);

}

void StatementDeclarations::accept(Visitor *v)
{
  v->visitStatementDeclarations(this);
}

StatementDeclarations *StatementDeclarations::clone() const
{
  return new StatementDeclarations(*this);
}



/********************   StatementInitialization    ********************/
StatementInitialization::StatementInitialization(Type *p1, Id p2, Exp *p3)
{
  type_ = p1;
  id_ = p2;
  exp_ = p3;

}

StatementInitialization::StatementInitialization(const StatementInitialization & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;
  exp_ = other.exp_->clone();

}

StatementInitialization &StatementInitialization::operator=(const StatementInitialization & other)
{
  StatementInitialization tmp(other);
  swap(tmp);
  return *this;
}

void StatementInitialization::swap(StatementInitialization & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);
  std::swap(exp_, other.exp_);

}

StatementInitialization::~StatementInitialization()
{
  delete(type_);
  delete(exp_);

}

void StatementInitialization::accept(Visitor *v)
{
  v->visitStatementInitialization(this);
}

StatementInitialization *StatementInitialization::clone() const
{
  return new StatementInitialization(*this);
}



/********************   StatementReturn    ********************/
StatementReturn::StatementReturn(Exp *p1)
{
  exp_ = p1;

}

StatementReturn::StatementReturn(const StatementReturn & other)
{
  exp_ = other.exp_->clone();

}

StatementReturn &StatementReturn::operator=(const StatementReturn & other)
{
  StatementReturn tmp(other);
  swap(tmp);
  return *this;
}

void StatementReturn::swap(StatementReturn & other)
{
  std::swap(exp_, other.exp_);

}

StatementReturn::~StatementReturn()
{
  delete(exp_);

}

void StatementReturn::accept(Visitor *v)
{
  v->visitStatementReturn(this);
}

StatementReturn *StatementReturn::clone() const
{
  return new StatementReturn(*this);
}



/********************   StatementWhile    ********************/
StatementWhile::StatementWhile(Exp *p1, Stm *p2)
{
  exp_ = p1;
  stm_ = p2;

}

StatementWhile::StatementWhile(const StatementWhile & other)
{
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

StatementWhile &StatementWhile::operator=(const StatementWhile & other)
{
  StatementWhile tmp(other);
  swap(tmp);
  return *this;
}

void StatementWhile::swap(StatementWhile & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

StatementWhile::~StatementWhile()
{
  delete(exp_);
  delete(stm_);

}

void StatementWhile::accept(Visitor *v)
{
  v->visitStatementWhile(this);
}

StatementWhile *StatementWhile::clone() const
{
  return new StatementWhile(*this);
}



/********************   StatementDo    ********************/
StatementDo::StatementDo(Stm *p1, Exp *p2)
{
  stm_ = p1;
  exp_ = p2;

}

StatementDo::StatementDo(const StatementDo & other)
{
  stm_ = other.stm_->clone();
  exp_ = other.exp_->clone();

}

StatementDo &StatementDo::operator=(const StatementDo & other)
{
  StatementDo tmp(other);
  swap(tmp);
  return *this;
}

void StatementDo::swap(StatementDo & other)
{
  std::swap(stm_, other.stm_);
  std::swap(exp_, other.exp_);

}

StatementDo::~StatementDo()
{
  delete(stm_);
  delete(exp_);

}

void StatementDo::accept(Visitor *v)
{
  v->visitStatementDo(this);
}

StatementDo *StatementDo::clone() const
{
  return new StatementDo(*this);
}



/********************   StatementFor    ********************/
StatementFor::StatementFor(Type *p1, Id p2, Exp *p3, Exp *p4, Stm *p5, Stm *p6)
{
  type_ = p1;
  id_ = p2;
  exp_1 = p3;
  exp_2 = p4;
  stm_1 = p5;
  stm_2 = p6;

}

StatementFor::StatementFor(const StatementFor & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  stm_1 = other.stm_1->clone();
  stm_2 = other.stm_2->clone();

}

StatementFor &StatementFor::operator=(const StatementFor & other)
{
  StatementFor tmp(other);
  swap(tmp);
  return *this;
}

void StatementFor::swap(StatementFor & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(stm_1, other.stm_1);
  std::swap(stm_2, other.stm_2);

}

StatementFor::~StatementFor()
{
  delete(type_);
  delete(exp_1);
  delete(exp_2);
  delete(stm_1);
  delete(stm_2);

}

void StatementFor::accept(Visitor *v)
{
  v->visitStatementFor(this);
}

StatementFor *StatementFor::clone() const
{
  return new StatementFor(*this);
}



/********************   StatementIf    ********************/
StatementIf::StatementIf(Exp *p1, Stm *p2)
{
  exp_ = p1;
  stm_ = p2;

}

StatementIf::StatementIf(const StatementIf & other)
{
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

StatementIf &StatementIf::operator=(const StatementIf & other)
{
  StatementIf tmp(other);
  swap(tmp);
  return *this;
}

void StatementIf::swap(StatementIf & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

StatementIf::~StatementIf()
{
  delete(exp_);
  delete(stm_);

}

void StatementIf::accept(Visitor *v)
{
  v->visitStatementIf(this);
}

StatementIf *StatementIf::clone() const
{
  return new StatementIf(*this);
}



/********************   StatementIfElse    ********************/
StatementIfElse::StatementIfElse(Exp *p1, Stm *p2, Stm *p3)
{
  exp_ = p1;
  stm_1 = p2;
  stm_2 = p3;

}

StatementIfElse::StatementIfElse(const StatementIfElse & other)
{
  exp_ = other.exp_->clone();
  stm_1 = other.stm_1->clone();
  stm_2 = other.stm_2->clone();

}

StatementIfElse &StatementIfElse::operator=(const StatementIfElse & other)
{
  StatementIfElse tmp(other);
  swap(tmp);
  return *this;
}

void StatementIfElse::swap(StatementIfElse & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_1, other.stm_1);
  std::swap(stm_2, other.stm_2);

}

StatementIfElse::~StatementIfElse()
{
  delete(exp_);
  delete(stm_1);
  delete(stm_2);

}

void StatementIfElse::accept(Visitor *v)
{
  v->visitStatementIfElse(this);
}

StatementIfElse *StatementIfElse::clone() const
{
  return new StatementIfElse(*this);
}



/********************   StatementBlock    ********************/
StatementBlock::StatementBlock(ListStm *p1)
{
  liststm_ = p1;

}

StatementBlock::StatementBlock(const StatementBlock & other)
{
  liststm_ = other.liststm_->clone();

}

StatementBlock &StatementBlock::operator=(const StatementBlock & other)
{
  StatementBlock tmp(other);
  swap(tmp);
  return *this;
}

void StatementBlock::swap(StatementBlock & other)
{
  std::swap(liststm_, other.liststm_);

}

StatementBlock::~StatementBlock()
{
  delete(liststm_);

}

void StatementBlock::accept(Visitor *v)
{
  v->visitStatementBlock(this);
}

StatementBlock *StatementBlock::clone() const
{
  return new StatementBlock(*this);
}



/********************   StatementStruct    ********************/
StatementStruct::StatementStruct(Id p1, ListStm *p2)
{
  id_ = p1;
  liststm_ = p2;

}

StatementStruct::StatementStruct(const StatementStruct & other)
{
  id_ = other.id_;
  liststm_ = other.liststm_->clone();

}

StatementStruct &StatementStruct::operator=(const StatementStruct & other)
{
  StatementStruct tmp(other);
  swap(tmp);
  return *this;
}

void StatementStruct::swap(StatementStruct & other)
{
  std::swap(id_, other.id_);
  std::swap(liststm_, other.liststm_);

}

StatementStruct::~StatementStruct()
{
  delete(liststm_);

}

void StatementStruct::accept(Visitor *v)
{
  v->visitStatementStruct(this);
}

StatementStruct *StatementStruct::clone() const
{
  return new StatementStruct(*this);
}



/********************   StatementTemplate    ********************/
StatementTemplate::StatementTemplate(Id p1, Type *p2, Exp *p3)
{
  id_ = p1;
  type_ = p2;
  exp_ = p3;

}

StatementTemplate::StatementTemplate(const StatementTemplate & other)
{
  id_ = other.id_;
  type_ = other.type_->clone();
  exp_ = other.exp_->clone();

}

StatementTemplate &StatementTemplate::operator=(const StatementTemplate & other)
{
  StatementTemplate tmp(other);
  swap(tmp);
  return *this;
}

void StatementTemplate::swap(StatementTemplate & other)
{
  std::swap(id_, other.id_);
  std::swap(type_, other.type_);
  std::swap(exp_, other.exp_);

}

StatementTemplate::~StatementTemplate()
{
  delete(type_);
  delete(exp_);

}

void StatementTemplate::accept(Visitor *v)
{
  v->visitStatementTemplate(this);
}

StatementTemplate *StatementTemplate::clone() const
{
  return new StatementTemplate(*this);
}



/********************   TemplateInstantiations    ********************/
TemplateInstantiations::TemplateInstantiations(ListType *p1)
{
  listtype_ = p1;

}

TemplateInstantiations::TemplateInstantiations(const TemplateInstantiations & other)
{
  listtype_ = other.listtype_->clone();

}

TemplateInstantiations &TemplateInstantiations::operator=(const TemplateInstantiations & other)
{
  TemplateInstantiations tmp(other);
  swap(tmp);
  return *this;
}

void TemplateInstantiations::swap(TemplateInstantiations & other)
{
  std::swap(listtype_, other.listtype_);

}

TemplateInstantiations::~TemplateInstantiations()
{
  delete(listtype_);

}

void TemplateInstantiations::accept(Visitor *v)
{
  v->visitTemplateInstantiations(this);
}

TemplateInstantiations *TemplateInstantiations::clone() const
{
  return new TemplateInstantiations(*this);
}



/********************   StatementDefinition    ********************/
StatementDefinition::StatementDefinition(Exp *p1)
{
  exp_ = p1;

}

StatementDefinition::StatementDefinition(const StatementDefinition & other)
{
  exp_ = other.exp_->clone();

}

StatementDefinition &StatementDefinition::operator=(const StatementDefinition & other)
{
  StatementDefinition tmp(other);
  swap(tmp);
  return *this;
}

void StatementDefinition::swap(StatementDefinition & other)
{
  std::swap(exp_, other.exp_);

}

StatementDefinition::~StatementDefinition()
{
  delete(exp_);

}

void StatementDefinition::accept(Visitor *v)
{
  v->visitStatementDefinition(this);
}

StatementDefinition *StatementDefinition::clone() const
{
  return new StatementDefinition(*this);
}



/********************   ArgumentDefinition    ********************/
ArgumentDefinition::ArgumentDefinition(Exp *p1)
{
  exp_ = p1;

}

ArgumentDefinition::ArgumentDefinition(const ArgumentDefinition & other)
{
  exp_ = other.exp_->clone();

}

ArgumentDefinition &ArgumentDefinition::operator=(const ArgumentDefinition & other)
{
  ArgumentDefinition tmp(other);
  swap(tmp);
  return *this;
}

void ArgumentDefinition::swap(ArgumentDefinition & other)
{
  std::swap(exp_, other.exp_);

}

ArgumentDefinition::~ArgumentDefinition()
{
  delete(exp_);

}

void ArgumentDefinition::accept(Visitor *v)
{
  v->visitArgumentDefinition(this);
}

ArgumentDefinition *ArgumentDefinition::clone() const
{
  return new ArgumentDefinition(*this);
}



/********************   TInt    ********************/
TInt::TInt()
{

}

TInt::TInt(const TInt & other)
{

}

TInt &TInt::operator=(const TInt & other)
{
  TInt tmp(other);
  swap(tmp);
  return *this;
}

void TInt::swap(TInt & other)
{

}

TInt::~TInt()
{

}

void TInt::accept(Visitor *v)
{
  v->visitTInt(this);
}

TInt *TInt::clone() const
{
  return new TInt(*this);
}



/********************   TBool    ********************/
TBool::TBool()
{

}

TBool::TBool(const TBool & other)
{

}

TBool &TBool::operator=(const TBool & other)
{
  TBool tmp(other);
  swap(tmp);
  return *this;
}

void TBool::swap(TBool & other)
{

}

TBool::~TBool()
{

}

void TBool::accept(Visitor *v)
{
  v->visitTBool(this);
}

TBool *TBool::clone() const
{
  return new TBool(*this);
}



/********************   TDouble    ********************/
TDouble::TDouble()
{

}

TDouble::TDouble(const TDouble & other)
{

}

TDouble &TDouble::operator=(const TDouble & other)
{
  TDouble tmp(other);
  swap(tmp);
  return *this;
}

void TDouble::swap(TDouble & other)
{

}

TDouble::~TDouble()
{

}

void TDouble::accept(Visitor *v)
{
  v->visitTDouble(this);
}

TDouble *TDouble::clone() const
{
  return new TDouble(*this);
}



/********************   TVoid    ********************/
TVoid::TVoid()
{

}

TVoid::TVoid(const TVoid & other)
{

}

TVoid &TVoid::operator=(const TVoid & other)
{
  TVoid tmp(other);
  swap(tmp);
  return *this;
}

void TVoid::swap(TVoid & other)
{

}

TVoid::~TVoid()
{

}

void TVoid::accept(Visitor *v)
{
  v->visitTVoid(this);
}

TVoid *TVoid::clone() const
{
  return new TVoid(*this);
}



/********************   TString    ********************/
TString::TString()
{

}

TString::TString(const TString & other)
{

}

TString &TString::operator=(const TString & other)
{
  TString tmp(other);
  swap(tmp);
  return *this;
}

void TString::swap(TString & other)
{

}

TString::~TString()
{

}

void TString::accept(Visitor *v)
{
  v->visitTString(this);
}

TString *TString::clone() const
{
  return new TString(*this);
}



/********************   TStringStd    ********************/
TStringStd::TStringStd()
{

}

TStringStd::TStringStd(const TStringStd & other)
{

}

TStringStd &TStringStd::operator=(const TStringStd & other)
{
  TStringStd tmp(other);
  swap(tmp);
  return *this;
}

void TStringStd::swap(TStringStd & other)
{

}

TStringStd::~TStringStd()
{

}

void TStringStd::accept(Visitor *v)
{
  v->visitTStringStd(this);
}

TStringStd *TStringStd::clone() const
{
  return new TStringStd(*this);
}



/********************   TVectorStd    ********************/
TVectorStd::TVectorStd()
{

}

TVectorStd::TVectorStd(const TVectorStd & other)
{

}

TVectorStd &TVectorStd::operator=(const TVectorStd & other)
{
  TVectorStd tmp(other);
  swap(tmp);
  return *this;
}

void TVectorStd::swap(TVectorStd & other)
{

}

TVectorStd::~TVectorStd()
{

}

void TVectorStd::accept(Visitor *v)
{
  v->visitTVectorStd(this);
}

TVectorStd *TVectorStd::clone() const
{
  return new TVectorStd(*this);
}



/********************   EId    ********************/
EId::EId(Id p1)
{
  id_ = p1;

}

EId::EId(const EId & other)
{
  id_ = other.id_;

}

EId &EId::operator=(const EId & other)
{
  EId tmp(other);
  swap(tmp);
  return *this;
}

void EId::swap(EId & other)
{
  std::swap(id_, other.id_);

}

EId::~EId()
{

}

void EId::accept(Visitor *v)
{
  v->visitEId(this);
}

EId *EId::clone() const
{
  return new EId(*this);
}



/********************   EInteger    ********************/
EInteger::EInteger(Integer p1)
{
  integer_ = p1;

}

EInteger::EInteger(const EInteger & other)
{
  integer_ = other.integer_;

}

EInteger &EInteger::operator=(const EInteger & other)
{
  EInteger tmp(other);
  swap(tmp);
  return *this;
}

void EInteger::swap(EInteger & other)
{
  std::swap(integer_, other.integer_);

}

EInteger::~EInteger()
{

}

void EInteger::accept(Visitor *v)
{
  v->visitEInteger(this);
}

EInteger *EInteger::clone() const
{
  return new EInteger(*this);
}



/********************   EString    ********************/
EString::EString(String p1)
{
  string_ = p1;

}

EString::EString(const EString & other)
{
  string_ = other.string_;

}

EString &EString::operator=(const EString & other)
{
  EString tmp(other);
  swap(tmp);
  return *this;
}

void EString::swap(EString & other)
{
  std::swap(string_, other.string_);

}

EString::~EString()
{

}

void EString::accept(Visitor *v)
{
  v->visitEString(this);
}

EString *EString::clone() const
{
  return new EString(*this);
}



/********************   EInde    ********************/
EInde::EInde(Exp *p1, Id p2)
{
  exp_ = p1;
  id_ = p2;

}

EInde::EInde(const EInde & other)
{
  exp_ = other.exp_->clone();
  id_ = other.id_;

}

EInde &EInde::operator=(const EInde & other)
{
  EInde tmp(other);
  swap(tmp);
  return *this;
}

void EInde::swap(EInde & other)
{
  std::swap(exp_, other.exp_);
  std::swap(id_, other.id_);

}

EInde::~EInde()
{
  delete(exp_);

}

void EInde::accept(Visitor *v)
{
  v->visitEInde(this);
}

EInde *EInde::clone() const
{
  return new EInde(*this);
}



/********************   EQCon    ********************/
EQCon::EQCon(Exp *p1, Id p2)
{
  exp_ = p1;
  id_ = p2;

}

EQCon::EQCon(const EQCon & other)
{
  exp_ = other.exp_->clone();
  id_ = other.id_;

}

EQCon &EQCon::operator=(const EQCon & other)
{
  EQCon tmp(other);
  swap(tmp);
  return *this;
}

void EQCon::swap(EQCon & other)
{
  std::swap(exp_, other.exp_);
  std::swap(id_, other.id_);

}

EQCon::~EQCon()
{
  delete(exp_);

}

void EQCon::accept(Visitor *v)
{
  v->visitEQCon(this);
}

EQCon *EQCon::clone() const
{
  return new EQCon(*this);
}



/********************   EFunC    ********************/
EFunC::EFunC(Exp *p1, ListExp *p2)
{
  exp_ = p1;
  listexp_ = p2;

}

EFunC::EFunC(const EFunC & other)
{
  exp_ = other.exp_->clone();
  listexp_ = other.listexp_->clone();

}

EFunC &EFunC::operator=(const EFunC & other)
{
  EFunC tmp(other);
  swap(tmp);
  return *this;
}

void EFunC::swap(EFunC & other)
{
  std::swap(exp_, other.exp_);
  std::swap(listexp_, other.listexp_);

}

EFunC::~EFunC()
{
  delete(exp_);
  delete(listexp_);

}

void EFunC::accept(Visitor *v)
{
  v->visitEFunC(this);
}

EFunC *EFunC::clone() const
{
  return new EFunC(*this);
}



/********************   EStPP    ********************/
EStPP::EStPP(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EStPP::EStPP(const EStPP & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EStPP &EStPP::operator=(const EStPP & other)
{
  EStPP tmp(other);
  swap(tmp);
  return *this;
}

void EStPP::swap(EStPP & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EStPP::~EStPP()
{
  delete(exp_1);
  delete(exp_2);

}

void EStPP::accept(Visitor *v)
{
  v->visitEStPP(this);
}

EStPP *EStPP::clone() const
{
  return new EStPP(*this);
}



/********************   EStPA    ********************/
EStPA::EStPA(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EStPA::EStPA(const EStPA & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EStPA &EStPA::operator=(const EStPA & other)
{
  EStPA tmp(other);
  swap(tmp);
  return *this;
}

void EStPA::swap(EStPA & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EStPA::~EStPA()
{
  delete(exp_1);
  delete(exp_2);

}

void EStPA::accept(Visitor *v)
{
  v->visitEStPA(this);
}

EStPA *EStPA::clone() const
{
  return new EStPA(*this);
}



/********************   EInEP    ********************/
EInEP::EInEP(Exp *p1)
{
  exp_ = p1;

}

EInEP::EInEP(const EInEP & other)
{
  exp_ = other.exp_->clone();

}

EInEP &EInEP::operator=(const EInEP & other)
{
  EInEP tmp(other);
  swap(tmp);
  return *this;
}

void EInEP::swap(EInEP & other)
{
  std::swap(exp_, other.exp_);

}

EInEP::~EInEP()
{
  delete(exp_);

}

void EInEP::accept(Visitor *v)
{
  v->visitEInEP(this);
}

EInEP *EInEP::clone() const
{
  return new EInEP(*this);
}



/********************   EDeEM    ********************/
EDeEM::EDeEM(Exp *p1)
{
  exp_ = p1;

}

EDeEM::EDeEM(const EDeEM & other)
{
  exp_ = other.exp_->clone();

}

EDeEM &EDeEM::operator=(const EDeEM & other)
{
  EDeEM tmp(other);
  swap(tmp);
  return *this;
}

void EDeEM::swap(EDeEM & other)
{
  std::swap(exp_, other.exp_);

}

EDeEM::~EDeEM()
{
  delete(exp_);

}

void EDeEM::accept(Visitor *v)
{
  v->visitEDeEM(this);
}

EDeEM *EDeEM::clone() const
{
  return new EDeEM(*this);
}



/********************   EDere    ********************/
EDere::EDere(Exp *p1)
{
  exp_ = p1;

}

EDere::EDere(const EDere & other)
{
  exp_ = other.exp_->clone();

}

EDere &EDere::operator=(const EDere & other)
{
  EDere tmp(other);
  swap(tmp);
  return *this;
}

void EDere::swap(EDere & other)
{
  std::swap(exp_, other.exp_);

}

EDere::~EDere()
{
  delete(exp_);

}

void EDere::accept(Visitor *v)
{
  v->visitEDere(this);
}

EDere *EDere::clone() const
{
  return new EDere(*this);
}



/********************   EInPE    ********************/
EInPE::EInPE(Exp *p1)
{
  exp_ = p1;

}

EInPE::EInPE(const EInPE & other)
{
  exp_ = other.exp_->clone();

}

EInPE &EInPE::operator=(const EInPE & other)
{
  EInPE tmp(other);
  swap(tmp);
  return *this;
}

void EInPE::swap(EInPE & other)
{
  std::swap(exp_, other.exp_);

}

EInPE::~EInPE()
{
  delete(exp_);

}

void EInPE::accept(Visitor *v)
{
  v->visitEInPE(this);
}

EInPE *EInPE::clone() const
{
  return new EInPE(*this);
}



/********************   EDeME    ********************/
EDeME::EDeME(Exp *p1)
{
  exp_ = p1;

}

EDeME::EDeME(const EDeME & other)
{
  exp_ = other.exp_->clone();

}

EDeME &EDeME::operator=(const EDeME & other)
{
  EDeME tmp(other);
  swap(tmp);
  return *this;
}

void EDeME::swap(EDeME & other)
{
  std::swap(exp_, other.exp_);

}

EDeME::~EDeME()
{
  delete(exp_);

}

void EDeME::accept(Visitor *v)
{
  v->visitEDeME(this);
}

EDeME *EDeME::clone() const
{
  return new EDeME(*this);
}



/********************   ENega    ********************/
ENega::ENega(Exp *p1)
{
  exp_ = p1;

}

ENega::ENega(const ENega & other)
{
  exp_ = other.exp_->clone();

}

ENega &ENega::operator=(const ENega & other)
{
  ENega tmp(other);
  swap(tmp);
  return *this;
}

void ENega::swap(ENega & other)
{
  std::swap(exp_, other.exp_);

}

ENega::~ENega()
{
  delete(exp_);

}

void ENega::accept(Visitor *v)
{
  v->visitENega(this);
}

ENega *ENega::clone() const
{
  return new ENega(*this);
}



/********************   EMult    ********************/
EMult::EMult(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMult::EMult(const EMult & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMult &EMult::operator=(const EMult & other)
{
  EMult tmp(other);
  swap(tmp);
  return *this;
}

void EMult::swap(EMult & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMult::~EMult()
{
  delete(exp_1);
  delete(exp_2);

}

void EMult::accept(Visitor *v)
{
  v->visitEMult(this);
}

EMult *EMult::clone() const
{
  return new EMult(*this);
}



/********************   EDivi    ********************/
EDivi::EDivi(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDivi::EDivi(const EDivi & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDivi &EDivi::operator=(const EDivi & other)
{
  EDivi tmp(other);
  swap(tmp);
  return *this;
}

void EDivi::swap(EDivi & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDivi::~EDivi()
{
  delete(exp_1);
  delete(exp_2);

}

void EDivi::accept(Visitor *v)
{
  v->visitEDivi(this);
}

EDivi *EDivi::clone() const
{
  return new EDivi(*this);
}



/********************   ERema    ********************/
ERema::ERema(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ERema::ERema(const ERema & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ERema &ERema::operator=(const ERema & other)
{
  ERema tmp(other);
  swap(tmp);
  return *this;
}

void ERema::swap(ERema & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ERema::~ERema()
{
  delete(exp_1);
  delete(exp_2);

}

void ERema::accept(Visitor *v)
{
  v->visitERema(this);
}

ERema *ERema::clone() const
{
  return new ERema(*this);
}



/********************   EAddi    ********************/
EAddi::EAddi(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAddi::EAddi(const EAddi & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAddi &EAddi::operator=(const EAddi & other)
{
  EAddi tmp(other);
  swap(tmp);
  return *this;
}

void EAddi::swap(EAddi & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAddi::~EAddi()
{
  delete(exp_1);
  delete(exp_2);

}

void EAddi::accept(Visitor *v)
{
  v->visitEAddi(this);
}

EAddi *EAddi::clone() const
{
  return new EAddi(*this);
}



/********************   ESubt    ********************/
ESubt::ESubt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESubt::ESubt(const ESubt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESubt &ESubt::operator=(const ESubt & other)
{
  ESubt tmp(other);
  swap(tmp);
  return *this;
}

void ESubt::swap(ESubt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESubt::~ESubt()
{
  delete(exp_1);
  delete(exp_2);

}

void ESubt::accept(Visitor *v)
{
  v->visitESubt(this);
}

ESubt *ESubt::clone() const
{
  return new ESubt(*this);
}



/********************   ELShi    ********************/
ELShi::ELShi(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELShi::ELShi(const ELShi & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELShi &ELShi::operator=(const ELShi & other)
{
  ELShi tmp(other);
  swap(tmp);
  return *this;
}

void ELShi::swap(ELShi & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELShi::~ELShi()
{
  delete(exp_1);
  delete(exp_2);

}

void ELShi::accept(Visitor *v)
{
  v->visitELShi(this);
}

ELShi *ELShi::clone() const
{
  return new ELShi(*this);
}



/********************   ERShi    ********************/
ERShi::ERShi(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ERShi::ERShi(const ERShi & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ERShi &ERShi::operator=(const ERShi & other)
{
  ERShi tmp(other);
  swap(tmp);
  return *this;
}

void ERShi::swap(ERShi & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ERShi::~ERShi()
{
  delete(exp_1);
  delete(exp_2);

}

void ERShi::accept(Visitor *v)
{
  v->visitERShi(this);
}

ERShi *ERShi::clone() const
{
  return new ERShi(*this);
}



/********************   ECoSm    ********************/
ECoSm::ECoSm(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ECoSm::ECoSm(const ECoSm & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ECoSm &ECoSm::operator=(const ECoSm & other)
{
  ECoSm tmp(other);
  swap(tmp);
  return *this;
}

void ECoSm::swap(ECoSm & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ECoSm::~ECoSm()
{
  delete(exp_1);
  delete(exp_2);

}

void ECoSm::accept(Visitor *v)
{
  v->visitECoSm(this);
}

ECoSm *ECoSm::clone() const
{
  return new ECoSm(*this);
}



/********************   ECoGr    ********************/
ECoGr::ECoGr(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ECoGr::ECoGr(const ECoGr & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ECoGr &ECoGr::operator=(const ECoGr & other)
{
  ECoGr tmp(other);
  swap(tmp);
  return *this;
}

void ECoGr::swap(ECoGr & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ECoGr::~ECoGr()
{
  delete(exp_1);
  delete(exp_2);

}

void ECoGr::accept(Visitor *v)
{
  v->visitECoGr(this);
}

ECoGr *ECoGr::clone() const
{
  return new ECoGr(*this);
}



/********************   ECoSE    ********************/
ECoSE::ECoSE(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ECoSE::ECoSE(const ECoSE & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ECoSE &ECoSE::operator=(const ECoSE & other)
{
  ECoSE tmp(other);
  swap(tmp);
  return *this;
}

void ECoSE::swap(ECoSE & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ECoSE::~ECoSE()
{
  delete(exp_1);
  delete(exp_2);

}

void ECoSE::accept(Visitor *v)
{
  v->visitECoSE(this);
}

ECoSE *ECoSE::clone() const
{
  return new ECoSE(*this);
}



/********************   ECoGE    ********************/
ECoGE::ECoGE(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ECoGE::ECoGE(const ECoGE & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ECoGE &ECoGE::operator=(const ECoGE & other)
{
  ECoGE tmp(other);
  swap(tmp);
  return *this;
}

void ECoGE::swap(ECoGE & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ECoGE::~ECoGE()
{
  delete(exp_1);
  delete(exp_2);

}

void ECoGE::accept(Visitor *v)
{
  v->visitECoGE(this);
}

ECoGE *ECoGE::clone() const
{
  return new ECoGE(*this);
}



/********************   EInEq    ********************/
EInEq::EInEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EInEq::EInEq(const EInEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EInEq &EInEq::operator=(const EInEq & other)
{
  EInEq tmp(other);
  swap(tmp);
  return *this;
}

void EInEq::swap(EInEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EInEq::~EInEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EInEq::accept(Visitor *v)
{
  v->visitEInEq(this);
}

EInEq *EInEq::clone() const
{
  return new EInEq(*this);
}



/********************   EEqua    ********************/
EEqua::EEqua(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EEqua::EEqua(const EEqua & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EEqua &EEqua::operator=(const EEqua & other)
{
  EEqua tmp(other);
  swap(tmp);
  return *this;
}

void EEqua::swap(EEqua & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EEqua::~EEqua()
{
  delete(exp_1);
  delete(exp_2);

}

void EEqua::accept(Visitor *v)
{
  v->visitEEqua(this);
}

EEqua *EEqua::clone() const
{
  return new EEqua(*this);
}



/********************   EConj    ********************/
EConj::EConj(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EConj::EConj(const EConj & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EConj &EConj::operator=(const EConj & other)
{
  EConj tmp(other);
  swap(tmp);
  return *this;
}

void EConj::swap(EConj & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EConj::~EConj()
{
  delete(exp_1);
  delete(exp_2);

}

void EConj::accept(Visitor *v)
{
  v->visitEConj(this);
}

EConj *EConj::clone() const
{
  return new EConj(*this);
}



/********************   EDisj    ********************/
EDisj::EDisj(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDisj::EDisj(const EDisj & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDisj &EDisj::operator=(const EDisj & other)
{
  EDisj tmp(other);
  swap(tmp);
  return *this;
}

void EDisj::swap(EDisj & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDisj::~EDisj()
{
  delete(exp_1);
  delete(exp_2);

}

void EDisj::accept(Visitor *v)
{
  v->visitEDisj(this);
}

EDisj *EDisj::clone() const
{
  return new EDisj(*this);
}



/********************   EAssi    ********************/
EAssi::EAssi(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAssi::EAssi(const EAssi & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAssi &EAssi::operator=(const EAssi & other)
{
  EAssi tmp(other);
  swap(tmp);
  return *this;
}

void EAssi::swap(EAssi & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAssi::~EAssi()
{
  delete(exp_1);
  delete(exp_2);

}

void EAssi::accept(Visitor *v)
{
  v->visitEAssi(this);
}

EAssi *EAssi::clone() const
{
  return new EAssi(*this);
}



/********************   EAsPl    ********************/
EAsPl::EAsPl(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAsPl::EAsPl(const EAsPl & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAsPl &EAsPl::operator=(const EAsPl & other)
{
  EAsPl tmp(other);
  swap(tmp);
  return *this;
}

void EAsPl::swap(EAsPl & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAsPl::~EAsPl()
{
  delete(exp_1);
  delete(exp_2);

}

void EAsPl::accept(Visitor *v)
{
  v->visitEAsPl(this);
}

EAsPl *EAsPl::clone() const
{
  return new EAsPl(*this);
}



/********************   EAsMi    ********************/
EAsMi::EAsMi(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAsMi::EAsMi(const EAsMi & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAsMi &EAsMi::operator=(const EAsMi & other)
{
  EAsMi tmp(other);
  swap(tmp);
  return *this;
}

void EAsMi::swap(EAsMi & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAsMi::~EAsMi()
{
  delete(exp_1);
  delete(exp_2);

}

void EAsMi::accept(Visitor *v)
{
  v->visitEAsMi(this);
}

EAsMi *EAsMi::clone() const
{
  return new EAsMi(*this);
}



/********************   ECond    ********************/
ECond::ECond(Exp *p1, Exp *p2, Exp *p3)
{
  exp_1 = p1;
  exp_2 = p2;
  exp_3 = p3;

}

ECond::ECond(const ECond & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  exp_3 = other.exp_3->clone();

}

ECond &ECond::operator=(const ECond & other)
{
  ECond tmp(other);
  swap(tmp);
  return *this;
}

void ECond::swap(ECond & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(exp_3, other.exp_3);

}

ECond::~ECond()
{
  delete(exp_1);
  delete(exp_2);
  delete(exp_3);

}

void ECond::accept(Visitor *v)
{
  v->visitECond(this);
}

ECond *ECond::clone() const
{
  return new ECond(*this);
}



/********************   EExce    ********************/
EExce::EExce(Exp *p1)
{
  exp_ = p1;

}

EExce::EExce(const EExce & other)
{
  exp_ = other.exp_->clone();

}

EExce &EExce::operator=(const EExce & other)
{
  EExce tmp(other);
  swap(tmp);
  return *this;
}

void EExce::swap(EExce & other)
{
  std::swap(exp_, other.exp_);

}

EExce::~EExce()
{
  delete(exp_);

}

void EExce::accept(Visitor *v)
{
  v->visitEExce(this);
}

EExce *EExce::clone() const
{
  return new EExce(*this);
}




/********************   ListDef    ********************/

void ListDef::accept(Visitor *v)
{
  v->visitListDef(this);
}


ListDef *ListDef::clone() const
{
  return new ListDef(*this);
}


/********************   ListArg    ********************/

void ListArg::accept(Visitor *v)
{
  v->visitListArg(this);
}


ListArg *ListArg::clone() const
{
  return new ListArg(*this);
}


/********************   ListStm    ********************/

void ListStm::accept(Visitor *v)
{
  v->visitListStm(this);
}


ListStm *ListStm::clone() const
{
  return new ListStm(*this);
}


/********************   ListId    ********************/

void ListId::accept(Visitor *v)
{
  v->visitListId(this);
}


ListId *ListId::clone() const
{
  return new ListId(*this);
}


/********************   ListType    ********************/

void ListType::accept(Visitor *v)
{
  v->visitListType(this);
}


ListType *ListType::clone() const
{
  return new ListType(*this);
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}





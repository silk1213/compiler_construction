#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class Definition;
class ArgumentList;
class Argument;
class Body;
class Stm;
class Struct;
class TypeDef;
class Decl;
class Var;
class QCon;
class Name;
class Exp;
class TempInst;
class TypeList;
class Type;
class BType;
class Literal;
class StringList;
class Id;
class Prog;
class FunctionDefIn;
class FunctionDef;
class Function;
class GlobVar;
class GlobStruct;
class GlobTypeDef;
class UsingNSDef;
class UsingDef;
class ArgumentListDef;
class ArgumentConstDecl;
class ArgumentDecl;
class ArgumentConsttype;
class ArgumentType;
class FuntionBody;
class EmptyBody;
class StmDecl;
class StmReturn;
class StmExit;
class StmWhile;
class StmDoWhile;
class StmFor;
class StmIfElse;
class StmIf;
class StmBlock;
class StmEmptyBlock;
class StmTypeDef;
class StmeStruct;
class StmExpression;
class StructDef;
class TypeDefForm;
class TypeDefForm2;
class ConstDecl;
class Declaration;
class VariableInitialization;
class VariableName;
class QualCon;
class QualConN;
class IdName;
class TempInstName;
class EIdent;
class ELiteral;
class EBracket;
class EIndex;
class EQCon;
class EFunCall;
class EStrucProj;
class EStrucPro;
class EInC;
class EDeC;
class EDeRef;
class EInCr;
class EDeCr;
class ENeg;
class EMul;
class EDiv;
class ERem;
class EAdd;
class ESub;
class ELSh;
class ERSh;
class EGT;
class ELT;
class EGQ;
class EGQ1;
class ELQ;
class ELQ1;
class EQu;
class EIQ;
class EAnd;
class EOr;
class EIs;
class EIsP;
class EIsM;
class ECond;
class EEx;
class TemplateInst;
class TypeListDef;
class Pointer;
class Reference;
class BaseType;
class TQCon;
class TInt;
class TVoid;
class TBool;
class TDouble;
class LStringList;
class LInt;
class LDouble;
class LChar;
class LStringListDef;
class LString;
class Identif;
class ListDefinition;
class ListArgument;
class ListStm;
class ListVar;
class ListDecl;
class ListExp;
class ListType;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitDefinition(Definition *p) = 0;
  virtual void visitArgumentList(ArgumentList *p) = 0;
  virtual void visitArgument(Argument *p) = 0;
  virtual void visitBody(Body *p) = 0;
  virtual void visitStm(Stm *p) = 0;
  virtual void visitStruct(Struct *p) = 0;
  virtual void visitTypeDef(TypeDef *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitVar(Var *p) = 0;
  virtual void visitQCon(QCon *p) = 0;
  virtual void visitName(Name *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitTempInst(TempInst *p) = 0;
  virtual void visitTypeList(TypeList *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitBType(BType *p) = 0;
  virtual void visitLiteral(Literal *p) = 0;
  virtual void visitStringList(StringList *p) = 0;
  virtual void visitId(Id *p) = 0;
  virtual void visitProg(Prog *p) = 0;
  virtual void visitFunctionDefIn(FunctionDefIn *p) = 0;
  virtual void visitFunctionDef(FunctionDef *p) = 0;
  virtual void visitFunction(Function *p) = 0;
  virtual void visitGlobVar(GlobVar *p) = 0;
  virtual void visitGlobStruct(GlobStruct *p) = 0;
  virtual void visitGlobTypeDef(GlobTypeDef *p) = 0;
  virtual void visitUsingNSDef(UsingNSDef *p) = 0;
  virtual void visitUsingDef(UsingDef *p) = 0;
  virtual void visitArgumentListDef(ArgumentListDef *p) = 0;
  virtual void visitArgumentConstDecl(ArgumentConstDecl *p) = 0;
  virtual void visitArgumentDecl(ArgumentDecl *p) = 0;
  virtual void visitArgumentConsttype(ArgumentConsttype *p) = 0;
  virtual void visitArgumentType(ArgumentType *p) = 0;
  virtual void visitFuntionBody(FuntionBody *p) = 0;
  virtual void visitEmptyBody(EmptyBody *p) = 0;
  virtual void visitStmDecl(StmDecl *p) = 0;
  virtual void visitStmReturn(StmReturn *p) = 0;
  virtual void visitStmExit(StmExit *p) = 0;
  virtual void visitStmWhile(StmWhile *p) = 0;
  virtual void visitStmDoWhile(StmDoWhile *p) = 0;
  virtual void visitStmFor(StmFor *p) = 0;
  virtual void visitStmIfElse(StmIfElse *p) = 0;
  virtual void visitStmIf(StmIf *p) = 0;
  virtual void visitStmBlock(StmBlock *p) = 0;
  virtual void visitStmEmptyBlock(StmEmptyBlock *p) = 0;
  virtual void visitStmTypeDef(StmTypeDef *p) = 0;
  virtual void visitStmeStruct(StmeStruct *p) = 0;
  virtual void visitStmExpression(StmExpression *p) = 0;
  virtual void visitStructDef(StructDef *p) = 0;
  virtual void visitTypeDefForm(TypeDefForm *p) = 0;
  virtual void visitTypeDefForm2(TypeDefForm2 *p) = 0;
  virtual void visitConstDecl(ConstDecl *p) = 0;
  virtual void visitDeclaration(Declaration *p) = 0;
  virtual void visitVariableInitialization(VariableInitialization *p) = 0;
  virtual void visitVariableName(VariableName *p) = 0;
  virtual void visitQualCon(QualCon *p) = 0;
  virtual void visitQualConN(QualConN *p) = 0;
  virtual void visitIdName(IdName *p) = 0;
  virtual void visitTempInstName(TempInstName *p) = 0;
  virtual void visitEIdent(EIdent *p) = 0;
  virtual void visitELiteral(ELiteral *p) = 0;
  virtual void visitEBracket(EBracket *p) = 0;
  virtual void visitEIndex(EIndex *p) = 0;
  virtual void visitEQCon(EQCon *p) = 0;
  virtual void visitEFunCall(EFunCall *p) = 0;
  virtual void visitEStrucProj(EStrucProj *p) = 0;
  virtual void visitEStrucPro(EStrucPro *p) = 0;
  virtual void visitEInC(EInC *p) = 0;
  virtual void visitEDeC(EDeC *p) = 0;
  virtual void visitEDeRef(EDeRef *p) = 0;
  virtual void visitEInCr(EInCr *p) = 0;
  virtual void visitEDeCr(EDeCr *p) = 0;
  virtual void visitENeg(ENeg *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitERem(ERem *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitESub(ESub *p) = 0;
  virtual void visitELSh(ELSh *p) = 0;
  virtual void visitERSh(ERSh *p) = 0;
  virtual void visitEGT(EGT *p) = 0;
  virtual void visitELT(ELT *p) = 0;
  virtual void visitEGQ(EGQ *p) = 0;
  virtual void visitEGQ1(EGQ1 *p) = 0;
  virtual void visitELQ(ELQ *p) = 0;
  virtual void visitELQ1(ELQ1 *p) = 0;
  virtual void visitEQu(EQu *p) = 0;
  virtual void visitEIQ(EIQ *p) = 0;
  virtual void visitEAnd(EAnd *p) = 0;
  virtual void visitEOr(EOr *p) = 0;
  virtual void visitEIs(EIs *p) = 0;
  virtual void visitEIsP(EIsP *p) = 0;
  virtual void visitEIsM(EIsM *p) = 0;
  virtual void visitECond(ECond *p) = 0;
  virtual void visitEEx(EEx *p) = 0;
  virtual void visitTemplateInst(TemplateInst *p) = 0;
  virtual void visitTypeListDef(TypeListDef *p) = 0;
  virtual void visitPointer(Pointer *p) = 0;
  virtual void visitReference(Reference *p) = 0;
  virtual void visitBaseType(BaseType *p) = 0;
  virtual void visitTQCon(TQCon *p) = 0;
  virtual void visitTInt(TInt *p) = 0;
  virtual void visitTVoid(TVoid *p) = 0;
  virtual void visitTBool(TBool *p) = 0;
  virtual void visitTDouble(TDouble *p) = 0;
  virtual void visitLStringList(LStringList *p) = 0;
  virtual void visitLInt(LInt *p) = 0;
  virtual void visitLDouble(LDouble *p) = 0;
  virtual void visitLChar(LChar *p) = 0;
  virtual void visitLStringListDef(LStringListDef *p) = 0;
  virtual void visitLString(LString *p) = 0;
  virtual void visitIdentif(Identif *p) = 0;
  virtual void visitListDefinition(ListDefinition *p) = 0;
  virtual void visitListArgument(ListArgument *p) = 0;
  virtual void visitListStm(ListStm *p) = 0;
  virtual void visitListVar(ListVar *p) = 0;
  virtual void visitListDecl(ListDecl *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;
  virtual void visitListType(ListType *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;

};

class Definition : public Visitable
{
public:
  virtual Definition *clone() const = 0;

};

class ArgumentList : public Visitable
{
public:
  virtual ArgumentList *clone() const = 0;

};

class Argument : public Visitable
{
public:
  virtual Argument *clone() const = 0;

};

class Body : public Visitable
{
public:
  virtual Body *clone() const = 0;

};

class Stm : public Visitable
{
public:
  virtual Stm *clone() const = 0;

};

class Struct : public Visitable
{
public:
  virtual Struct *clone() const = 0;

};

class TypeDef : public Visitable
{
public:
  virtual TypeDef *clone() const = 0;

};

class Decl : public Visitable
{
public:
  virtual Decl *clone() const = 0;

};

class Var : public Visitable
{
public:
  virtual Var *clone() const = 0;

};

class QCon : public Visitable
{
public:
  virtual QCon *clone() const = 0;

};

class Name : public Visitable
{
public:
  virtual Name *clone() const = 0;

};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;

};

class TempInst : public Visitable
{
public:
  virtual TempInst *clone() const = 0;

};

class TypeList : public Visitable
{
public:
  virtual TypeList *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};

class BType : public Visitable
{
public:
  virtual BType *clone() const = 0;

};

class Literal : public Visitable
{
public:
  virtual Literal *clone() const = 0;

};

class StringList : public Visitable
{
public:
  virtual StringList *clone() const = 0;

};

class Id : public Visitable
{
public:
  virtual Id *clone() const = 0;

};



class Prog : public Program
{
public:
  ListDefinition *listdefinition_;

  Prog(const Prog &);
  Prog &operator=(const Prog &);
  Prog(ListDefinition *p1);
  ~Prog();
  virtual void accept(Visitor *v);
  virtual Prog *clone() const;
  void swap(Prog &);
};

class FunctionDefIn : public Definition
{
public:
  Type *type_;
  Id *id_;
  ArgumentList *argumentlist_;
  Body *body_;

  FunctionDefIn(const FunctionDefIn &);
  FunctionDefIn &operator=(const FunctionDefIn &);
  FunctionDefIn(Type *p1, Id *p2, ArgumentList *p3, Body *p4);
  ~FunctionDefIn();
  virtual void accept(Visitor *v);
  virtual FunctionDefIn *clone() const;
  void swap(FunctionDefIn &);
};

class FunctionDef : public Definition
{
public:
  Type *type_;
  Id *id_;
  ArgumentList *argumentlist_;
  Body *body_;

  FunctionDef(const FunctionDef &);
  FunctionDef &operator=(const FunctionDef &);
  FunctionDef(Type *p1, Id *p2, ArgumentList *p3, Body *p4);
  ~FunctionDef();
  virtual void accept(Visitor *v);
  virtual FunctionDef *clone() const;
  void swap(FunctionDef &);
};

class Function : public Definition
{
public:
  Type *type_;
  Id *id_;
  ArgumentList *argumentlist_;

  Function(const Function &);
  Function &operator=(const Function &);
  Function(Type *p1, Id *p2, ArgumentList *p3);
  ~Function();
  virtual void accept(Visitor *v);
  virtual Function *clone() const;
  void swap(Function &);
};

class GlobVar : public Definition
{
public:
  Decl *decl_;

  GlobVar(const GlobVar &);
  GlobVar &operator=(const GlobVar &);
  GlobVar(Decl *p1);
  ~GlobVar();
  virtual void accept(Visitor *v);
  virtual GlobVar *clone() const;
  void swap(GlobVar &);
};

class GlobStruct : public Definition
{
public:
  Struct *struct_;

  GlobStruct(const GlobStruct &);
  GlobStruct &operator=(const GlobStruct &);
  GlobStruct(Struct *p1);
  ~GlobStruct();
  virtual void accept(Visitor *v);
  virtual GlobStruct *clone() const;
  void swap(GlobStruct &);
};

class GlobTypeDef : public Definition
{
public:
  TypeDef *typedef_;

  GlobTypeDef(const GlobTypeDef &);
  GlobTypeDef &operator=(const GlobTypeDef &);
  GlobTypeDef(TypeDef *p1);
  ~GlobTypeDef();
  virtual void accept(Visitor *v);
  virtual GlobTypeDef *clone() const;
  void swap(GlobTypeDef &);
};

class UsingNSDef : public Definition
{
public:
  Id *id_;

  UsingNSDef(const UsingNSDef &);
  UsingNSDef &operator=(const UsingNSDef &);
  UsingNSDef(Id *p1);
  ~UsingNSDef();
  virtual void accept(Visitor *v);
  virtual UsingNSDef *clone() const;
  void swap(UsingNSDef &);
};

class UsingDef : public Definition
{
public:
  QCon *qcon_;

  UsingDef(const UsingDef &);
  UsingDef &operator=(const UsingDef &);
  UsingDef(QCon *p1);
  ~UsingDef();
  virtual void accept(Visitor *v);
  virtual UsingDef *clone() const;
  void swap(UsingDef &);
};

class ArgumentListDef : public ArgumentList
{
public:
  ListArgument *listargument_;

  ArgumentListDef(const ArgumentListDef &);
  ArgumentListDef &operator=(const ArgumentListDef &);
  ArgumentListDef(ListArgument *p1);
  ~ArgumentListDef();
  virtual void accept(Visitor *v);
  virtual ArgumentListDef *clone() const;
  void swap(ArgumentListDef &);
};

class ArgumentConstDecl : public Argument
{
public:
  Type *type_;
  Exp *exp_;

  ArgumentConstDecl(const ArgumentConstDecl &);
  ArgumentConstDecl &operator=(const ArgumentConstDecl &);
  ArgumentConstDecl(Type *p1, Exp *p2);
  ~ArgumentConstDecl();
  virtual void accept(Visitor *v);
  virtual ArgumentConstDecl *clone() const;
  void swap(ArgumentConstDecl &);
};

class ArgumentDecl : public Argument
{
public:
  Type *type_;
  Exp *exp_;

  ArgumentDecl(const ArgumentDecl &);
  ArgumentDecl &operator=(const ArgumentDecl &);
  ArgumentDecl(Type *p1, Exp *p2);
  ~ArgumentDecl();
  virtual void accept(Visitor *v);
  virtual ArgumentDecl *clone() const;
  void swap(ArgumentDecl &);
};

class ArgumentConsttype : public Argument
{
public:
  Type *type_;

  ArgumentConsttype(const ArgumentConsttype &);
  ArgumentConsttype &operator=(const ArgumentConsttype &);
  ArgumentConsttype(Type *p1);
  ~ArgumentConsttype();
  virtual void accept(Visitor *v);
  virtual ArgumentConsttype *clone() const;
  void swap(ArgumentConsttype &);
};

class ArgumentType : public Argument
{
public:
  Type *type_;

  ArgumentType(const ArgumentType &);
  ArgumentType &operator=(const ArgumentType &);
  ArgumentType(Type *p1);
  ~ArgumentType();
  virtual void accept(Visitor *v);
  virtual ArgumentType *clone() const;
  void swap(ArgumentType &);
};

class FuntionBody : public Body
{
public:
  ListStm *liststm_;

  FuntionBody(const FuntionBody &);
  FuntionBody &operator=(const FuntionBody &);
  FuntionBody(ListStm *p1);
  ~FuntionBody();
  virtual void accept(Visitor *v);
  virtual FuntionBody *clone() const;
  void swap(FuntionBody &);
};

class EmptyBody : public Body
{
public:

  EmptyBody(const EmptyBody &);
  EmptyBody &operator=(const EmptyBody &);
  EmptyBody();
  ~EmptyBody();
  virtual void accept(Visitor *v);
  virtual EmptyBody *clone() const;
  void swap(EmptyBody &);
};

class StmDecl : public Stm
{
public:
  Decl *decl_;

  StmDecl(const StmDecl &);
  StmDecl &operator=(const StmDecl &);
  StmDecl(Decl *p1);
  ~StmDecl();
  virtual void accept(Visitor *v);
  virtual StmDecl *clone() const;
  void swap(StmDecl &);
};

class StmReturn : public Stm
{
public:
  Exp *exp_;

  StmReturn(const StmReturn &);
  StmReturn &operator=(const StmReturn &);
  StmReturn(Exp *p1);
  ~StmReturn();
  virtual void accept(Visitor *v);
  virtual StmReturn *clone() const;
  void swap(StmReturn &);
};

class StmExit : public Stm
{
public:
  Exp *exp_;

  StmExit(const StmExit &);
  StmExit &operator=(const StmExit &);
  StmExit(Exp *p1);
  ~StmExit();
  virtual void accept(Visitor *v);
  virtual StmExit *clone() const;
  void swap(StmExit &);
};

class StmWhile : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  StmWhile(const StmWhile &);
  StmWhile &operator=(const StmWhile &);
  StmWhile(Exp *p1, Stm *p2);
  ~StmWhile();
  virtual void accept(Visitor *v);
  virtual StmWhile *clone() const;
  void swap(StmWhile &);
};

class StmDoWhile : public Stm
{
public:
  Stm *stm_;
  Exp *exp_;

  StmDoWhile(const StmDoWhile &);
  StmDoWhile &operator=(const StmDoWhile &);
  StmDoWhile(Stm *p1, Exp *p2);
  ~StmDoWhile();
  virtual void accept(Visitor *v);
  virtual StmDoWhile *clone() const;
  void swap(StmDoWhile &);
};

class StmFor : public Stm
{
public:
  Decl *decl_;
  Exp *exp_1;
  Exp *exp_2;
  Stm *stm_;

  StmFor(const StmFor &);
  StmFor &operator=(const StmFor &);
  StmFor(Decl *p1, Exp *p2, Exp *p3, Stm *p4);
  ~StmFor();
  virtual void accept(Visitor *v);
  virtual StmFor *clone() const;
  void swap(StmFor &);
};

class StmIfElse : public Stm
{
public:
  Exp *exp_;
  Stm *stm_1;
  Stm *stm_2;

  StmIfElse(const StmIfElse &);
  StmIfElse &operator=(const StmIfElse &);
  StmIfElse(Exp *p1, Stm *p2, Stm *p3);
  ~StmIfElse();
  virtual void accept(Visitor *v);
  virtual StmIfElse *clone() const;
  void swap(StmIfElse &);
};

class StmIf : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  StmIf(const StmIf &);
  StmIf &operator=(const StmIf &);
  StmIf(Exp *p1, Stm *p2);
  ~StmIf();
  virtual void accept(Visitor *v);
  virtual StmIf *clone() const;
  void swap(StmIf &);
};

class StmBlock : public Stm
{
public:
  ListStm *liststm_;

  StmBlock(const StmBlock &);
  StmBlock &operator=(const StmBlock &);
  StmBlock(ListStm *p1);
  ~StmBlock();
  virtual void accept(Visitor *v);
  virtual StmBlock *clone() const;
  void swap(StmBlock &);
};

class StmEmptyBlock : public Stm
{
public:

  StmEmptyBlock(const StmEmptyBlock &);
  StmEmptyBlock &operator=(const StmEmptyBlock &);
  StmEmptyBlock();
  ~StmEmptyBlock();
  virtual void accept(Visitor *v);
  virtual StmEmptyBlock *clone() const;
  void swap(StmEmptyBlock &);
};

class StmTypeDef : public Stm
{
public:
  TypeDef *typedef_;

  StmTypeDef(const StmTypeDef &);
  StmTypeDef &operator=(const StmTypeDef &);
  StmTypeDef(TypeDef *p1);
  ~StmTypeDef();
  virtual void accept(Visitor *v);
  virtual StmTypeDef *clone() const;
  void swap(StmTypeDef &);
};

class StmeStruct : public Stm
{
public:
  Struct *struct_;

  StmeStruct(const StmeStruct &);
  StmeStruct &operator=(const StmeStruct &);
  StmeStruct(Struct *p1);
  ~StmeStruct();
  virtual void accept(Visitor *v);
  virtual StmeStruct *clone() const;
  void swap(StmeStruct &);
};

class StmExpression : public Stm
{
public:
  Exp *exp_;

  StmExpression(const StmExpression &);
  StmExpression &operator=(const StmExpression &);
  StmExpression(Exp *p1);
  ~StmExpression();
  virtual void accept(Visitor *v);
  virtual StmExpression *clone() const;
  void swap(StmExpression &);
};

class StructDef : public Struct
{
public:
  Id *id_;
  ListDecl *listdecl_;

  StructDef(const StructDef &);
  StructDef &operator=(const StructDef &);
  StructDef(Id *p1, ListDecl *p2);
  ~StructDef();
  virtual void accept(Visitor *v);
  virtual StructDef *clone() const;
  void swap(StructDef &);
};

class TypeDefForm : public TypeDef
{
public:
  Type *type_;
  Id *id_;

  TypeDefForm(const TypeDefForm &);
  TypeDefForm &operator=(const TypeDefForm &);
  TypeDefForm(Type *p1, Id *p2);
  ~TypeDefForm();
  virtual void accept(Visitor *v);
  virtual TypeDefForm *clone() const;
  void swap(TypeDefForm &);
};

class TypeDefForm2 : public TypeDef
{
public:
  Type *type_;

  TypeDefForm2(const TypeDefForm2 &);
  TypeDefForm2 &operator=(const TypeDefForm2 &);
  TypeDefForm2(Type *p1);
  ~TypeDefForm2();
  virtual void accept(Visitor *v);
  virtual TypeDefForm2 *clone() const;
  void swap(TypeDefForm2 &);
};

class ConstDecl : public Decl
{
public:
  Type *type_;
  ListVar *listvar_;

  ConstDecl(const ConstDecl &);
  ConstDecl &operator=(const ConstDecl &);
  ConstDecl(Type *p1, ListVar *p2);
  ~ConstDecl();
  virtual void accept(Visitor *v);
  virtual ConstDecl *clone() const;
  void swap(ConstDecl &);
};

class Declaration : public Decl
{
public:
  Type *type_;
  ListVar *listvar_;

  Declaration(const Declaration &);
  Declaration &operator=(const Declaration &);
  Declaration(Type *p1, ListVar *p2);
  ~Declaration();
  virtual void accept(Visitor *v);
  virtual Declaration *clone() const;
  void swap(Declaration &);
};

class VariableInitialization : public Var
{
public:
  Id *id_;
  Exp *exp_;

  VariableInitialization(const VariableInitialization &);
  VariableInitialization &operator=(const VariableInitialization &);
  VariableInitialization(Id *p1, Exp *p2);
  ~VariableInitialization();
  virtual void accept(Visitor *v);
  virtual VariableInitialization *clone() const;
  void swap(VariableInitialization &);
};

class VariableName : public Var
{
public:
  Id *id_;

  VariableName(const VariableName &);
  VariableName &operator=(const VariableName &);
  VariableName(Id *p1);
  ~VariableName();
  virtual void accept(Visitor *v);
  virtual VariableName *clone() const;
  void swap(VariableName &);
};

class QualCon : public QCon
{
public:
  QCon *qcon_;
  Name *name_;

  QualCon(const QualCon &);
  QualCon &operator=(const QualCon &);
  QualCon(QCon *p1, Name *p2);
  ~QualCon();
  virtual void accept(Visitor *v);
  virtual QualCon *clone() const;
  void swap(QualCon &);
};

class QualConN : public QCon
{
public:
  Name *name_;

  QualConN(const QualConN &);
  QualConN &operator=(const QualConN &);
  QualConN(Name *p1);
  ~QualConN();
  virtual void accept(Visitor *v);
  virtual QualConN *clone() const;
  void swap(QualConN &);
};

class IdName : public Name
{
public:
  Id *id_;

  IdName(const IdName &);
  IdName &operator=(const IdName &);
  IdName(Id *p1);
  ~IdName();
  virtual void accept(Visitor *v);
  virtual IdName *clone() const;
  void swap(IdName &);
};

class TempInstName : public Name
{
public:
  TempInst *tempinst_;

  TempInstName(const TempInstName &);
  TempInstName &operator=(const TempInstName &);
  TempInstName(TempInst *p1);
  ~TempInstName();
  virtual void accept(Visitor *v);
  virtual TempInstName *clone() const;
  void swap(TempInstName &);
};

class EIdent : public Exp
{
public:
  Id *id_;

  EIdent(const EIdent &);
  EIdent &operator=(const EIdent &);
  EIdent(Id *p1);
  ~EIdent();
  virtual void accept(Visitor *v);
  virtual EIdent *clone() const;
  void swap(EIdent &);
};

class ELiteral : public Exp
{
public:
  Literal *literal_;

  ELiteral(const ELiteral &);
  ELiteral &operator=(const ELiteral &);
  ELiteral(Literal *p1);
  ~ELiteral();
  virtual void accept(Visitor *v);
  virtual ELiteral *clone() const;
  void swap(ELiteral &);
};

class EBracket : public Exp
{
public:
  Exp *exp_;

  EBracket(const EBracket &);
  EBracket &operator=(const EBracket &);
  EBracket(Exp *p1);
  ~EBracket();
  virtual void accept(Visitor *v);
  virtual EBracket *clone() const;
  void swap(EBracket &);
};

class EIndex : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EIndex(const EIndex &);
  EIndex &operator=(const EIndex &);
  EIndex(Exp *p1, Exp *p2);
  ~EIndex();
  virtual void accept(Visitor *v);
  virtual EIndex *clone() const;
  void swap(EIndex &);
};

class EQCon : public Exp
{
public:
  QCon *qcon_;

  EQCon(const EQCon &);
  EQCon &operator=(const EQCon &);
  EQCon(QCon *p1);
  ~EQCon();
  virtual void accept(Visitor *v);
  virtual EQCon *clone() const;
  void swap(EQCon &);
};

class EFunCall : public Exp
{
public:
  Exp *exp_;
  ListExp *listexp_;

  EFunCall(const EFunCall &);
  EFunCall &operator=(const EFunCall &);
  EFunCall(Exp *p1, ListExp *p2);
  ~EFunCall();
  virtual void accept(Visitor *v);
  virtual EFunCall *clone() const;
  void swap(EFunCall &);
};

class EStrucProj : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EStrucProj(const EStrucProj &);
  EStrucProj &operator=(const EStrucProj &);
  EStrucProj(Exp *p1, Exp *p2);
  ~EStrucProj();
  virtual void accept(Visitor *v);
  virtual EStrucProj *clone() const;
  void swap(EStrucProj &);
};

class EStrucPro : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EStrucPro(const EStrucPro &);
  EStrucPro &operator=(const EStrucPro &);
  EStrucPro(Exp *p1, Exp *p2);
  ~EStrucPro();
  virtual void accept(Visitor *v);
  virtual EStrucPro *clone() const;
  void swap(EStrucPro &);
};

class EInC : public Exp
{
public:
  Exp *exp_;

  EInC(const EInC &);
  EInC &operator=(const EInC &);
  EInC(Exp *p1);
  ~EInC();
  virtual void accept(Visitor *v);
  virtual EInC *clone() const;
  void swap(EInC &);
};

class EDeC : public Exp
{
public:
  Exp *exp_;

  EDeC(const EDeC &);
  EDeC &operator=(const EDeC &);
  EDeC(Exp *p1);
  ~EDeC();
  virtual void accept(Visitor *v);
  virtual EDeC *clone() const;
  void swap(EDeC &);
};

class EDeRef : public Exp
{
public:
  Exp *exp_;

  EDeRef(const EDeRef &);
  EDeRef &operator=(const EDeRef &);
  EDeRef(Exp *p1);
  ~EDeRef();
  virtual void accept(Visitor *v);
  virtual EDeRef *clone() const;
  void swap(EDeRef &);
};

class EInCr : public Exp
{
public:
  Exp *exp_;

  EInCr(const EInCr &);
  EInCr &operator=(const EInCr &);
  EInCr(Exp *p1);
  ~EInCr();
  virtual void accept(Visitor *v);
  virtual EInCr *clone() const;
  void swap(EInCr &);
};

class EDeCr : public Exp
{
public:
  Exp *exp_;

  EDeCr(const EDeCr &);
  EDeCr &operator=(const EDeCr &);
  EDeCr(Exp *p1);
  ~EDeCr();
  virtual void accept(Visitor *v);
  virtual EDeCr *clone() const;
  void swap(EDeCr &);
};

class ENeg : public Exp
{
public:
  Exp *exp_;

  ENeg(const ENeg &);
  ENeg &operator=(const ENeg &);
  ENeg(Exp *p1);
  ~ENeg();
  virtual void accept(Visitor *v);
  virtual ENeg *clone() const;
  void swap(ENeg &);
};

class EMul : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Exp *p1, Exp *p2);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual EMul *clone() const;
  void swap(EMul &);
};

class EDiv : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Exp *p1, Exp *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual EDiv *clone() const;
  void swap(EDiv &);
};

class ERem : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ERem(const ERem &);
  ERem &operator=(const ERem &);
  ERem(Exp *p1, Exp *p2);
  ~ERem();
  virtual void accept(Visitor *v);
  virtual ERem *clone() const;
  void swap(ERem &);
};

class EAdd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Exp *p1, Exp *p2);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual EAdd *clone() const;
  void swap(EAdd &);
};

class ESub : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ESub(const ESub &);
  ESub &operator=(const ESub &);
  ESub(Exp *p1, Exp *p2);
  ~ESub();
  virtual void accept(Visitor *v);
  virtual ESub *clone() const;
  void swap(ESub &);
};

class ELSh : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELSh(const ELSh &);
  ELSh &operator=(const ELSh &);
  ELSh(Exp *p1, Exp *p2);
  ~ELSh();
  virtual void accept(Visitor *v);
  virtual ELSh *clone() const;
  void swap(ELSh &);
};

class ERSh : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ERSh(const ERSh &);
  ERSh &operator=(const ERSh &);
  ERSh(Exp *p1, Exp *p2);
  ~ERSh();
  virtual void accept(Visitor *v);
  virtual ERSh *clone() const;
  void swap(ERSh &);
};

class EGT : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGT(const EGT &);
  EGT &operator=(const EGT &);
  EGT(Exp *p1, Exp *p2);
  ~EGT();
  virtual void accept(Visitor *v);
  virtual EGT *clone() const;
  void swap(EGT &);
};

class ELT : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELT(const ELT &);
  ELT &operator=(const ELT &);
  ELT(Exp *p1, Exp *p2);
  ~ELT();
  virtual void accept(Visitor *v);
  virtual ELT *clone() const;
  void swap(ELT &);
};

class EGQ : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGQ(const EGQ &);
  EGQ &operator=(const EGQ &);
  EGQ(Exp *p1, Exp *p2);
  ~EGQ();
  virtual void accept(Visitor *v);
  virtual EGQ *clone() const;
  void swap(EGQ &);
};

class EGQ1 : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGQ1(const EGQ1 &);
  EGQ1 &operator=(const EGQ1 &);
  EGQ1(Exp *p1, Exp *p2);
  ~EGQ1();
  virtual void accept(Visitor *v);
  virtual EGQ1 *clone() const;
  void swap(EGQ1 &);
};

class ELQ : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELQ(const ELQ &);
  ELQ &operator=(const ELQ &);
  ELQ(Exp *p1, Exp *p2);
  ~ELQ();
  virtual void accept(Visitor *v);
  virtual ELQ *clone() const;
  void swap(ELQ &);
};

class ELQ1 : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELQ1(const ELQ1 &);
  ELQ1 &operator=(const ELQ1 &);
  ELQ1(Exp *p1, Exp *p2);
  ~ELQ1();
  virtual void accept(Visitor *v);
  virtual ELQ1 *clone() const;
  void swap(ELQ1 &);
};

class EQu : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EQu(const EQu &);
  EQu &operator=(const EQu &);
  EQu(Exp *p1, Exp *p2);
  ~EQu();
  virtual void accept(Visitor *v);
  virtual EQu *clone() const;
  void swap(EQu &);
};

class EIQ : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EIQ(const EIQ &);
  EIQ &operator=(const EIQ &);
  EIQ(Exp *p1, Exp *p2);
  ~EIQ();
  virtual void accept(Visitor *v);
  virtual EIQ *clone() const;
  void swap(EIQ &);
};

class EAnd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Exp *p1, Exp *p2);
  ~EAnd();
  virtual void accept(Visitor *v);
  virtual EAnd *clone() const;
  void swap(EAnd &);
};

class EOr : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Exp *p1, Exp *p2);
  ~EOr();
  virtual void accept(Visitor *v);
  virtual EOr *clone() const;
  void swap(EOr &);
};

class EIs : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EIs(const EIs &);
  EIs &operator=(const EIs &);
  EIs(Exp *p1, Exp *p2);
  ~EIs();
  virtual void accept(Visitor *v);
  virtual EIs *clone() const;
  void swap(EIs &);
};

class EIsP : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EIsP(const EIsP &);
  EIsP &operator=(const EIsP &);
  EIsP(Exp *p1, Exp *p2);
  ~EIsP();
  virtual void accept(Visitor *v);
  virtual EIsP *clone() const;
  void swap(EIsP &);
};

class EIsM : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EIsM(const EIsM &);
  EIsM &operator=(const EIsM &);
  EIsM(Exp *p1, Exp *p2);
  ~EIsM();
  virtual void accept(Visitor *v);
  virtual EIsM *clone() const;
  void swap(EIsM &);
};

class ECond : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;
  Exp *exp_3;

  ECond(const ECond &);
  ECond &operator=(const ECond &);
  ECond(Exp *p1, Exp *p2, Exp *p3);
  ~ECond();
  virtual void accept(Visitor *v);
  virtual ECond *clone() const;
  void swap(ECond &);
};

class EEx : public Exp
{
public:
  Exp *exp_;

  EEx(const EEx &);
  EEx &operator=(const EEx &);
  EEx(Exp *p1);
  ~EEx();
  virtual void accept(Visitor *v);
  virtual EEx *clone() const;
  void swap(EEx &);
};

class TemplateInst : public TempInst
{
public:
  Id *id_;
  TypeList *typelist_;

  TemplateInst(const TemplateInst &);
  TemplateInst &operator=(const TemplateInst &);
  TemplateInst(Id *p1, TypeList *p2);
  ~TemplateInst();
  virtual void accept(Visitor *v);
  virtual TemplateInst *clone() const;
  void swap(TemplateInst &);
};

class TypeListDef : public TypeList
{
public:
  ListType *listtype_;

  TypeListDef(const TypeListDef &);
  TypeListDef &operator=(const TypeListDef &);
  TypeListDef(ListType *p1);
  ~TypeListDef();
  virtual void accept(Visitor *v);
  virtual TypeListDef *clone() const;
  void swap(TypeListDef &);
};

class Pointer : public Type
{
public:
  BType *btype_;

  Pointer(const Pointer &);
  Pointer &operator=(const Pointer &);
  Pointer(BType *p1);
  ~Pointer();
  virtual void accept(Visitor *v);
  virtual Pointer *clone() const;
  void swap(Pointer &);
};

class Reference : public Type
{
public:
  BType *btype_;

  Reference(const Reference &);
  Reference &operator=(const Reference &);
  Reference(BType *p1);
  ~Reference();
  virtual void accept(Visitor *v);
  virtual Reference *clone() const;
  void swap(Reference &);
};

class BaseType : public Type
{
public:
  BType *btype_;

  BaseType(const BaseType &);
  BaseType &operator=(const BaseType &);
  BaseType(BType *p1);
  ~BaseType();
  virtual void accept(Visitor *v);
  virtual BaseType *clone() const;
  void swap(BaseType &);
};

class TQCon : public BType
{
public:
  QCon *qcon_;

  TQCon(const TQCon &);
  TQCon &operator=(const TQCon &);
  TQCon(QCon *p1);
  ~TQCon();
  virtual void accept(Visitor *v);
  virtual TQCon *clone() const;
  void swap(TQCon &);
};

class TInt : public BType
{
public:

  TInt(const TInt &);
  TInt &operator=(const TInt &);
  TInt();
  ~TInt();
  virtual void accept(Visitor *v);
  virtual TInt *clone() const;
  void swap(TInt &);
};

class TVoid : public BType
{
public:

  TVoid(const TVoid &);
  TVoid &operator=(const TVoid &);
  TVoid();
  ~TVoid();
  virtual void accept(Visitor *v);
  virtual TVoid *clone() const;
  void swap(TVoid &);
};

class TBool : public BType
{
public:

  TBool(const TBool &);
  TBool &operator=(const TBool &);
  TBool();
  ~TBool();
  virtual void accept(Visitor *v);
  virtual TBool *clone() const;
  void swap(TBool &);
};

class TDouble : public BType
{
public:

  TDouble(const TDouble &);
  TDouble &operator=(const TDouble &);
  TDouble();
  ~TDouble();
  virtual void accept(Visitor *v);
  virtual TDouble *clone() const;
  void swap(TDouble &);
};

class LStringList : public Literal
{
public:
  StringList *stringlist_;

  LStringList(const LStringList &);
  LStringList &operator=(const LStringList &);
  LStringList(StringList *p1);
  ~LStringList();
  virtual void accept(Visitor *v);
  virtual LStringList *clone() const;
  void swap(LStringList &);
};

class LInt : public Literal
{
public:
  Integer integer_;

  LInt(const LInt &);
  LInt &operator=(const LInt &);
  LInt(Integer p1);
  ~LInt();
  virtual void accept(Visitor *v);
  virtual LInt *clone() const;
  void swap(LInt &);
};

class LDouble : public Literal
{
public:
  Double double_;

  LDouble(const LDouble &);
  LDouble &operator=(const LDouble &);
  LDouble(Double p1);
  ~LDouble();
  virtual void accept(Visitor *v);
  virtual LDouble *clone() const;
  void swap(LDouble &);
};

class LChar : public Literal
{
public:
  Char char_;

  LChar(const LChar &);
  LChar &operator=(const LChar &);
  LChar(Char p1);
  ~LChar();
  virtual void accept(Visitor *v);
  virtual LChar *clone() const;
  void swap(LChar &);
};

class LStringListDef : public StringList
{
public:
  StringList *stringlist_;
  String string_;

  LStringListDef(const LStringListDef &);
  LStringListDef &operator=(const LStringListDef &);
  LStringListDef(StringList *p1, String p2);
  ~LStringListDef();
  virtual void accept(Visitor *v);
  virtual LStringListDef *clone() const;
  void swap(LStringListDef &);
};

class LString : public StringList
{
public:
  String string_;

  LString(const LString &);
  LString &operator=(const LString &);
  LString(String p1);
  ~LString();
  virtual void accept(Visitor *v);
  virtual LString *clone() const;
  void swap(LString &);
};

class Identif : public Id
{
public:
  Ident ident_;

  Identif(const Identif &);
  Identif &operator=(const Identif &);
  Identif(Ident p1);
  ~Identif();
  virtual void accept(Visitor *v);
  virtual Identif *clone() const;
  void swap(Identif &);
};



class ListDefinition : public Visitable, public std::vector<Definition*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDefinition *clone() const;
};

class ListArgument : public Visitable, public std::vector<Argument*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListArgument *clone() const;
};

class ListStm : public Visitable, public std::vector<Stm*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStm *clone() const;
};

class ListVar : public Visitable, public std::vector<Var*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListVar *clone() const;
};

class ListDecl : public Visitable, public std::vector<Decl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDecl *clone() const;
};

class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};

class ListType : public Visitable, public std::vector<Type*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListType *clone() const;
};



#endif

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string Id;


/********************   Forward Declarations    ********************/

class Prog;
class Def;
class Stm;
class Arg;
class Exp;
class Con;
class Type;
class PDefs;
class DefinitionFunction;
class DefinitionUsing;
class StatementDeclaration;
class StatementDeclarations;
class StatementInitialization;
class StatementReturn;
class StatementWhile;
class StatementDo;
class StatementFor;
class StatementIf;
class StatementIfElse;
class StatementBlock;
class StatementStruct;
class StatementTemplate;
class StatementTypedef;
class TemplateInstantiations;
class StatementDefinition;
class ArgumentDefinition;
class EId;
class EInteger;
class EString;
class EInde;
class EQCon;
class EQCo;
class EFunC;
class EStPP;
class EStPA;
class EInEP;
class EDeEM;
class EDere;
class EInPE;
class EDeME;
class ENega;
class EMult;
class EDivi;
class ERema;
class EAddi;
class ESubt;
class ELShi;
class ERShi;
class ECoSm;
class ECoGr;
class ECoSE;
class ECoGE;
class EInEq;
class EEqua;
class EConj;
class EDisj;
class EAssi;
class EAsPl;
class EAsMi;
class ECond;
class EExce;
class CStd;
class TInt;
class TBool;
class TDouble;
class TVoid;
class TString;
class TVector;
class TConDef;
class ListDef;
class ListArg;
class ListStm;
class ListId;
class ListType;
class ListExp;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProg(Prog *p) = 0;
  virtual void visitDef(Def *p) = 0;
  virtual void visitStm(Stm *p) = 0;
  virtual void visitArg(Arg *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitCon(Con *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitPDefs(PDefs *p) = 0;
  virtual void visitDefinitionFunction(DefinitionFunction *p) = 0;
  virtual void visitDefinitionUsing(DefinitionUsing *p) = 0;
  virtual void visitStatementDeclaration(StatementDeclaration *p) = 0;
  virtual void visitStatementDeclarations(StatementDeclarations *p) = 0;
  virtual void visitStatementInitialization(StatementInitialization *p) = 0;
  virtual void visitStatementReturn(StatementReturn *p) = 0;
  virtual void visitStatementWhile(StatementWhile *p) = 0;
  virtual void visitStatementDo(StatementDo *p) = 0;
  virtual void visitStatementFor(StatementFor *p) = 0;
  virtual void visitStatementIf(StatementIf *p) = 0;
  virtual void visitStatementIfElse(StatementIfElse *p) = 0;
  virtual void visitStatementBlock(StatementBlock *p) = 0;
  virtual void visitStatementStruct(StatementStruct *p) = 0;
  virtual void visitStatementTemplate(StatementTemplate *p) = 0;
  virtual void visitStatementTypedef(StatementTypedef *p) = 0;
  virtual void visitTemplateInstantiations(TemplateInstantiations *p) = 0;
  virtual void visitStatementDefinition(StatementDefinition *p) = 0;
  virtual void visitArgumentDefinition(ArgumentDefinition *p) = 0;
  virtual void visitEId(EId *p) = 0;
  virtual void visitEInteger(EInteger *p) = 0;
  virtual void visitEString(EString *p) = 0;
  virtual void visitEInde(EInde *p) = 0;
  virtual void visitEQCon(EQCon *p) = 0;
  virtual void visitEQCo(EQCo *p) = 0;
  virtual void visitEFunC(EFunC *p) = 0;
  virtual void visitEStPP(EStPP *p) = 0;
  virtual void visitEStPA(EStPA *p) = 0;
  virtual void visitEInEP(EInEP *p) = 0;
  virtual void visitEDeEM(EDeEM *p) = 0;
  virtual void visitEDere(EDere *p) = 0;
  virtual void visitEInPE(EInPE *p) = 0;
  virtual void visitEDeME(EDeME *p) = 0;
  virtual void visitENega(ENega *p) = 0;
  virtual void visitEMult(EMult *p) = 0;
  virtual void visitEDivi(EDivi *p) = 0;
  virtual void visitERema(ERema *p) = 0;
  virtual void visitEAddi(EAddi *p) = 0;
  virtual void visitESubt(ESubt *p) = 0;
  virtual void visitELShi(ELShi *p) = 0;
  virtual void visitERShi(ERShi *p) = 0;
  virtual void visitECoSm(ECoSm *p) = 0;
  virtual void visitECoGr(ECoGr *p) = 0;
  virtual void visitECoSE(ECoSE *p) = 0;
  virtual void visitECoGE(ECoGE *p) = 0;
  virtual void visitEInEq(EInEq *p) = 0;
  virtual void visitEEqua(EEqua *p) = 0;
  virtual void visitEConj(EConj *p) = 0;
  virtual void visitEDisj(EDisj *p) = 0;
  virtual void visitEAssi(EAssi *p) = 0;
  virtual void visitEAsPl(EAsPl *p) = 0;
  virtual void visitEAsMi(EAsMi *p) = 0;
  virtual void visitECond(ECond *p) = 0;
  virtual void visitEExce(EExce *p) = 0;
  virtual void visitCStd(CStd *p) = 0;
  virtual void visitTInt(TInt *p) = 0;
  virtual void visitTBool(TBool *p) = 0;
  virtual void visitTDouble(TDouble *p) = 0;
  virtual void visitTVoid(TVoid *p) = 0;
  virtual void visitTString(TString *p) = 0;
  virtual void visitTVector(TVector *p) = 0;
  virtual void visitTConDef(TConDef *p) = 0;
  virtual void visitListDef(ListDef *p) = 0;
  virtual void visitListArg(ListArg *p) = 0;
  virtual void visitListStm(ListStm *p) = 0;
  virtual void visitListId(ListId *p) = 0;
  virtual void visitListType(ListType *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitId(Id x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Prog : public Visitable
{
public:
  virtual Prog *clone() const = 0;

};

class Def : public Visitable
{
public:
  virtual Def *clone() const = 0;

};

class Stm : public Visitable
{
public:
  virtual Stm *clone() const = 0;

};

class Arg : public Visitable
{
public:
  virtual Arg *clone() const = 0;

};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;

};

class Con : public Visitable
{
public:
  virtual Con *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};



class PDefs : public Prog
{
public:
  ListDef *listdef_;

  PDefs(const PDefs &);
  PDefs &operator=(const PDefs &);
  PDefs(ListDef *p1);
  ~PDefs();
  virtual void accept(Visitor *v);
  virtual PDefs *clone() const;
  void swap(PDefs &);
};

class DefinitionFunction : public Def
{
public:
  Type *type_;
  Id id_;
  ListArg *listarg_;
  ListStm *liststm_;

  DefinitionFunction(const DefinitionFunction &);
  DefinitionFunction &operator=(const DefinitionFunction &);
  DefinitionFunction(Type *p1, Id p2, ListArg *p3, ListStm *p4);
  ~DefinitionFunction();
  virtual void accept(Visitor *v);
  virtual DefinitionFunction *clone() const;
  void swap(DefinitionFunction &);
};

class DefinitionUsing : public Def
{
public:
  Exp *exp_;

  DefinitionUsing(const DefinitionUsing &);
  DefinitionUsing &operator=(const DefinitionUsing &);
  DefinitionUsing(Exp *p1);
  ~DefinitionUsing();
  virtual void accept(Visitor *v);
  virtual DefinitionUsing *clone() const;
  void swap(DefinitionUsing &);
};

class StatementDeclaration : public Stm
{
public:
  Type *type_;
  Id id_;

  StatementDeclaration(const StatementDeclaration &);
  StatementDeclaration &operator=(const StatementDeclaration &);
  StatementDeclaration(Type *p1, Id p2);
  ~StatementDeclaration();
  virtual void accept(Visitor *v);
  virtual StatementDeclaration *clone() const;
  void swap(StatementDeclaration &);
};

class StatementDeclarations : public Stm
{
public:
  Type *type_;
  Id id_;
  ListId *listid_;

  StatementDeclarations(const StatementDeclarations &);
  StatementDeclarations &operator=(const StatementDeclarations &);
  StatementDeclarations(Type *p1, Id p2, ListId *p3);
  ~StatementDeclarations();
  virtual void accept(Visitor *v);
  virtual StatementDeclarations *clone() const;
  void swap(StatementDeclarations &);
};

class StatementInitialization : public Stm
{
public:
  Type *type_;
  Id id_;
  Exp *exp_;

  StatementInitialization(const StatementInitialization &);
  StatementInitialization &operator=(const StatementInitialization &);
  StatementInitialization(Type *p1, Id p2, Exp *p3);
  ~StatementInitialization();
  virtual void accept(Visitor *v);
  virtual StatementInitialization *clone() const;
  void swap(StatementInitialization &);
};

class StatementReturn : public Stm
{
public:
  Exp *exp_;

  StatementReturn(const StatementReturn &);
  StatementReturn &operator=(const StatementReturn &);
  StatementReturn(Exp *p1);
  ~StatementReturn();
  virtual void accept(Visitor *v);
  virtual StatementReturn *clone() const;
  void swap(StatementReturn &);
};

class StatementWhile : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  StatementWhile(const StatementWhile &);
  StatementWhile &operator=(const StatementWhile &);
  StatementWhile(Exp *p1, Stm *p2);
  ~StatementWhile();
  virtual void accept(Visitor *v);
  virtual StatementWhile *clone() const;
  void swap(StatementWhile &);
};

class StatementDo : public Stm
{
public:
  Stm *stm_;
  Exp *exp_;

  StatementDo(const StatementDo &);
  StatementDo &operator=(const StatementDo &);
  StatementDo(Stm *p1, Exp *p2);
  ~StatementDo();
  virtual void accept(Visitor *v);
  virtual StatementDo *clone() const;
  void swap(StatementDo &);
};

class StatementFor : public Stm
{
public:
  Type *type_;
  Id id_;
  Exp *exp_1;
  Exp *exp_2;
  Stm *stm_1;
  Stm *stm_2;

  StatementFor(const StatementFor &);
  StatementFor &operator=(const StatementFor &);
  StatementFor(Type *p1, Id p2, Exp *p3, Exp *p4, Stm *p5, Stm *p6);
  ~StatementFor();
  virtual void accept(Visitor *v);
  virtual StatementFor *clone() const;
  void swap(StatementFor &);
};

class StatementIf : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  StatementIf(const StatementIf &);
  StatementIf &operator=(const StatementIf &);
  StatementIf(Exp *p1, Stm *p2);
  ~StatementIf();
  virtual void accept(Visitor *v);
  virtual StatementIf *clone() const;
  void swap(StatementIf &);
};

class StatementIfElse : public Stm
{
public:
  Exp *exp_;
  Stm *stm_1;
  Stm *stm_2;

  StatementIfElse(const StatementIfElse &);
  StatementIfElse &operator=(const StatementIfElse &);
  StatementIfElse(Exp *p1, Stm *p2, Stm *p3);
  ~StatementIfElse();
  virtual void accept(Visitor *v);
  virtual StatementIfElse *clone() const;
  void swap(StatementIfElse &);
};

class StatementBlock : public Stm
{
public:
  ListStm *liststm_;

  StatementBlock(const StatementBlock &);
  StatementBlock &operator=(const StatementBlock &);
  StatementBlock(ListStm *p1);
  ~StatementBlock();
  virtual void accept(Visitor *v);
  virtual StatementBlock *clone() const;
  void swap(StatementBlock &);
};

class StatementStruct : public Stm
{
public:
  Id id_;
  ListStm *liststm_;

  StatementStruct(const StatementStruct &);
  StatementStruct &operator=(const StatementStruct &);
  StatementStruct(Id p1, ListStm *p2);
  ~StatementStruct();
  virtual void accept(Visitor *v);
  virtual StatementStruct *clone() const;
  void swap(StatementStruct &);
};

class StatementTemplate : public Stm
{
public:
  Id id_;
  Type *type_;
  Exp *exp_;

  StatementTemplate(const StatementTemplate &);
  StatementTemplate &operator=(const StatementTemplate &);
  StatementTemplate(Id p1, Type *p2, Exp *p3);
  ~StatementTemplate();
  virtual void accept(Visitor *v);
  virtual StatementTemplate *clone() const;
  void swap(StatementTemplate &);
};

class StatementTypedef : public Stm
{
public:
  Exp *exp_;

  StatementTypedef(const StatementTypedef &);
  StatementTypedef &operator=(const StatementTypedef &);
  StatementTypedef(Exp *p1);
  ~StatementTypedef();
  virtual void accept(Visitor *v);
  virtual StatementTypedef *clone() const;
  void swap(StatementTypedef &);
};

class TemplateInstantiations : public Stm
{
public:
  ListType *listtype_;

  TemplateInstantiations(const TemplateInstantiations &);
  TemplateInstantiations &operator=(const TemplateInstantiations &);
  TemplateInstantiations(ListType *p1);
  ~TemplateInstantiations();
  virtual void accept(Visitor *v);
  virtual TemplateInstantiations *clone() const;
  void swap(TemplateInstantiations &);
};

class StatementDefinition : public Stm
{
public:
  Exp *exp_;

  StatementDefinition(const StatementDefinition &);
  StatementDefinition &operator=(const StatementDefinition &);
  StatementDefinition(Exp *p1);
  ~StatementDefinition();
  virtual void accept(Visitor *v);
  virtual StatementDefinition *clone() const;
  void swap(StatementDefinition &);
};

class ArgumentDefinition : public Arg
{
public:
  Exp *exp_;

  ArgumentDefinition(const ArgumentDefinition &);
  ArgumentDefinition &operator=(const ArgumentDefinition &);
  ArgumentDefinition(Exp *p1);
  ~ArgumentDefinition();
  virtual void accept(Visitor *v);
  virtual ArgumentDefinition *clone() const;
  void swap(ArgumentDefinition &);
};

class CStd : public Con
{
public:

  CStd(const CStd &);
  CStd &operator=(const CStd &);
  CStd();
  ~CStd();
  virtual void accept(Visitor *v);
  virtual CStd *clone() const;
  void swap(CStd &);
};

class TInt : public Type
{
public:

  TInt(const TInt &);
  TInt &operator=(const TInt &);
  TInt();
  ~TInt();
  virtual void accept(Visitor *v);
  virtual TInt *clone() const;
  void swap(TInt &);
};

class TBool : public Type
{
public:

  TBool(const TBool &);
  TBool &operator=(const TBool &);
  TBool();
  ~TBool();
  virtual void accept(Visitor *v);
  virtual TBool *clone() const;
  void swap(TBool &);
};

class TDouble : public Type
{
public:

  TDouble(const TDouble &);
  TDouble &operator=(const TDouble &);
  TDouble();
  ~TDouble();
  virtual void accept(Visitor *v);
  virtual TDouble *clone() const;
  void swap(TDouble &);
};

class TVoid : public Type
{
public:

  TVoid(const TVoid &);
  TVoid &operator=(const TVoid &);
  TVoid();
  ~TVoid();
  virtual void accept(Visitor *v);
  virtual TVoid *clone() const;
  void swap(TVoid &);
};

class TString : public Type
{
public:

  TString(const TString &);
  TString &operator=(const TString &);
  TString();
  ~TString();
  virtual void accept(Visitor *v);
  virtual TString *clone() const;
  void swap(TString &);
};

class TVector : public Type
{
public:

  TVector(const TVector &);
  TVector &operator=(const TVector &);
  TVector();
  ~TVector();
  virtual void accept(Visitor *v);
  virtual TVector *clone() const;
  void swap(TVector &);
};

class TConDef : public Type
{
public:
  Con *con_;
  Type *type_;

  TConDef(const TConDef &);
  TConDef &operator=(const TConDef &);
  TConDef(Con *p1, Type *p2);
  ~TConDef();
  virtual void accept(Visitor *v);
  virtual TConDef *clone() const;
  void swap(TConDef &);
};

class EId : public Exp
{
public:
  Id id_;

  EId(const EId &);
  EId &operator=(const EId &);
  EId(Id p1);
  ~EId();
  virtual void accept(Visitor *v);
  virtual EId *clone() const;
  void swap(EId &);
};

class EInteger : public Exp
{
public:
  Integer integer_;

  EInteger(const EInteger &);
  EInteger &operator=(const EInteger &);
  EInteger(Integer p1);
  ~EInteger();
  virtual void accept(Visitor *v);
  virtual EInteger *clone() const;
  void swap(EInteger &);
};

class EString : public Exp
{
public:
  String string_;

  EString(const EString &);
  EString &operator=(const EString &);
  EString(String p1);
  ~EString();
  virtual void accept(Visitor *v);
  virtual EString *clone() const;
  void swap(EString &);
};

class EInde : public Exp
{
public:
  Exp *exp_;
  Id id_;

  EInde(const EInde &);
  EInde &operator=(const EInde &);
  EInde(Exp *p1, Id p2);
  ~EInde();
  virtual void accept(Visitor *v);
  virtual EInde *clone() const;
  void swap(EInde &);
};

class EQCon : public Exp
{
public:
  Con *con_;
  Id id_;

  EQCon(const EQCon &);
  EQCon &operator=(const EQCon &);
  EQCon(Con *p1, Id p2);
  ~EQCon();
  virtual void accept(Visitor *v);
  virtual EQCon *clone() const;
  void swap(EQCon &);
};

class EQCo : public Exp
{
public:
  Con *con_;
  Type *type_;

  EQCo(const EQCo &);
  EQCo &operator=(const EQCo &);
  EQCo(Con *p1, Type *p2);
  ~EQCo();
  virtual void accept(Visitor *v);
  virtual EQCo *clone() const;
  void swap(EQCo &);
};

class EFunC : public Exp
{
public:
  Exp *exp_;
  ListExp *listexp_;

  EFunC(const EFunC &);
  EFunC &operator=(const EFunC &);
  EFunC(Exp *p1, ListExp *p2);
  ~EFunC();
  virtual void accept(Visitor *v);
  virtual EFunC *clone() const;
  void swap(EFunC &);
};

class EStPP : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EStPP(const EStPP &);
  EStPP &operator=(const EStPP &);
  EStPP(Exp *p1, Exp *p2);
  ~EStPP();
  virtual void accept(Visitor *v);
  virtual EStPP *clone() const;
  void swap(EStPP &);
};

class EStPA : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EStPA(const EStPA &);
  EStPA &operator=(const EStPA &);
  EStPA(Exp *p1, Exp *p2);
  ~EStPA();
  virtual void accept(Visitor *v);
  virtual EStPA *clone() const;
  void swap(EStPA &);
};

class EInEP : public Exp
{
public:
  Exp *exp_;

  EInEP(const EInEP &);
  EInEP &operator=(const EInEP &);
  EInEP(Exp *p1);
  ~EInEP();
  virtual void accept(Visitor *v);
  virtual EInEP *clone() const;
  void swap(EInEP &);
};

class EDeEM : public Exp
{
public:
  Exp *exp_;

  EDeEM(const EDeEM &);
  EDeEM &operator=(const EDeEM &);
  EDeEM(Exp *p1);
  ~EDeEM();
  virtual void accept(Visitor *v);
  virtual EDeEM *clone() const;
  void swap(EDeEM &);
};

class EDere : public Exp
{
public:
  Exp *exp_;

  EDere(const EDere &);
  EDere &operator=(const EDere &);
  EDere(Exp *p1);
  ~EDere();
  virtual void accept(Visitor *v);
  virtual EDere *clone() const;
  void swap(EDere &);
};

class EInPE : public Exp
{
public:
  Exp *exp_;

  EInPE(const EInPE &);
  EInPE &operator=(const EInPE &);
  EInPE(Exp *p1);
  ~EInPE();
  virtual void accept(Visitor *v);
  virtual EInPE *clone() const;
  void swap(EInPE &);
};

class EDeME : public Exp
{
public:
  Exp *exp_;

  EDeME(const EDeME &);
  EDeME &operator=(const EDeME &);
  EDeME(Exp *p1);
  ~EDeME();
  virtual void accept(Visitor *v);
  virtual EDeME *clone() const;
  void swap(EDeME &);
};

class ENega : public Exp
{
public:
  Exp *exp_;

  ENega(const ENega &);
  ENega &operator=(const ENega &);
  ENega(Exp *p1);
  ~ENega();
  virtual void accept(Visitor *v);
  virtual ENega *clone() const;
  void swap(ENega &);
};

class EMult : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMult(const EMult &);
  EMult &operator=(const EMult &);
  EMult(Exp *p1, Exp *p2);
  ~EMult();
  virtual void accept(Visitor *v);
  virtual EMult *clone() const;
  void swap(EMult &);
};

class EDivi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDivi(const EDivi &);
  EDivi &operator=(const EDivi &);
  EDivi(Exp *p1, Exp *p2);
  ~EDivi();
  virtual void accept(Visitor *v);
  virtual EDivi *clone() const;
  void swap(EDivi &);
};

class ERema : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ERema(const ERema &);
  ERema &operator=(const ERema &);
  ERema(Exp *p1, Exp *p2);
  ~ERema();
  virtual void accept(Visitor *v);
  virtual ERema *clone() const;
  void swap(ERema &);
};

class EAddi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAddi(const EAddi &);
  EAddi &operator=(const EAddi &);
  EAddi(Exp *p1, Exp *p2);
  ~EAddi();
  virtual void accept(Visitor *v);
  virtual EAddi *clone() const;
  void swap(EAddi &);
};

class ESubt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ESubt(const ESubt &);
  ESubt &operator=(const ESubt &);
  ESubt(Exp *p1, Exp *p2);
  ~ESubt();
  virtual void accept(Visitor *v);
  virtual ESubt *clone() const;
  void swap(ESubt &);
};

class ELShi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELShi(const ELShi &);
  ELShi &operator=(const ELShi &);
  ELShi(Exp *p1, Exp *p2);
  ~ELShi();
  virtual void accept(Visitor *v);
  virtual ELShi *clone() const;
  void swap(ELShi &);
};

class ERShi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ERShi(const ERShi &);
  ERShi &operator=(const ERShi &);
  ERShi(Exp *p1, Exp *p2);
  ~ERShi();
  virtual void accept(Visitor *v);
  virtual ERShi *clone() const;
  void swap(ERShi &);
};

class ECoSm : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ECoSm(const ECoSm &);
  ECoSm &operator=(const ECoSm &);
  ECoSm(Exp *p1, Exp *p2);
  ~ECoSm();
  virtual void accept(Visitor *v);
  virtual ECoSm *clone() const;
  void swap(ECoSm &);
};

class ECoGr : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ECoGr(const ECoGr &);
  ECoGr &operator=(const ECoGr &);
  ECoGr(Exp *p1, Exp *p2);
  ~ECoGr();
  virtual void accept(Visitor *v);
  virtual ECoGr *clone() const;
  void swap(ECoGr &);
};

class ECoSE : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ECoSE(const ECoSE &);
  ECoSE &operator=(const ECoSE &);
  ECoSE(Exp *p1, Exp *p2);
  ~ECoSE();
  virtual void accept(Visitor *v);
  virtual ECoSE *clone() const;
  void swap(ECoSE &);
};

class ECoGE : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ECoGE(const ECoGE &);
  ECoGE &operator=(const ECoGE &);
  ECoGE(Exp *p1, Exp *p2);
  ~ECoGE();
  virtual void accept(Visitor *v);
  virtual ECoGE *clone() const;
  void swap(ECoGE &);
};

class EInEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EInEq(const EInEq &);
  EInEq &operator=(const EInEq &);
  EInEq(Exp *p1, Exp *p2);
  ~EInEq();
  virtual void accept(Visitor *v);
  virtual EInEq *clone() const;
  void swap(EInEq &);
};

class EEqua : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EEqua(const EEqua &);
  EEqua &operator=(const EEqua &);
  EEqua(Exp *p1, Exp *p2);
  ~EEqua();
  virtual void accept(Visitor *v);
  virtual EEqua *clone() const;
  void swap(EEqua &);
};

class EConj : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EConj(const EConj &);
  EConj &operator=(const EConj &);
  EConj(Exp *p1, Exp *p2);
  ~EConj();
  virtual void accept(Visitor *v);
  virtual EConj *clone() const;
  void swap(EConj &);
};

class EDisj : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDisj(const EDisj &);
  EDisj &operator=(const EDisj &);
  EDisj(Exp *p1, Exp *p2);
  ~EDisj();
  virtual void accept(Visitor *v);
  virtual EDisj *clone() const;
  void swap(EDisj &);
};

class EAssi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAssi(const EAssi &);
  EAssi &operator=(const EAssi &);
  EAssi(Exp *p1, Exp *p2);
  ~EAssi();
  virtual void accept(Visitor *v);
  virtual EAssi *clone() const;
  void swap(EAssi &);
};

class EAsPl : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAsPl(const EAsPl &);
  EAsPl &operator=(const EAsPl &);
  EAsPl(Exp *p1, Exp *p2);
  ~EAsPl();
  virtual void accept(Visitor *v);
  virtual EAsPl *clone() const;
  void swap(EAsPl &);
};

class EAsMi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAsMi(const EAsMi &);
  EAsMi &operator=(const EAsMi &);
  EAsMi(Exp *p1, Exp *p2);
  ~EAsMi();
  virtual void accept(Visitor *v);
  virtual EAsMi *clone() const;
  void swap(EAsMi &);
};

class ECond : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;
  Exp *exp_3;

  ECond(const ECond &);
  ECond &operator=(const ECond &);
  ECond(Exp *p1, Exp *p2, Exp *p3);
  ~ECond();
  virtual void accept(Visitor *v);
  virtual ECond *clone() const;
  void swap(ECond &);
};

class EExce : public Exp
{
public:
  Exp *exp_;

  EExce(const EExce &);
  EExce &operator=(const EExce &);
  EExce(Exp *p1);
  ~EExce();
  virtual void accept(Visitor *v);
  virtual EExce *clone() const;
  void swap(EExce &);
};



class ListDef : public Visitable, public std::vector<Def*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDef *clone() const;
};

class ListArg : public Visitable, public std::vector<Arg*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListArg *clone() const;
};

class ListStm : public Visitable, public std::vector<Stm*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStm *clone() const;
};

class ListId : public Visitable, public std::vector<Id>
{
public:
  virtual void accept(Visitor *v);
  virtual ListId *clone() const;
};

class ListType : public Visitable, public std::vector<Type*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListType *clone() const;
};

class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};



#endif

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string Id;


/********************   Forward Declarations    ********************/

class Def;
class Stm;
class Arg;
class Exp;
class Type;
class Lit;
class Func;
class SDecl;
class SDecls;
class SInit;
class SReturn;
class SWhile;
class SDo;
class SFor;
class SIf;
class SIfElse;
class SBlock;
class STypedef;
class SStruct;
class TemplateInstantiations;
class QualifiedConstants;
class StatementDefinition;
class ArgumentDefinition;
class EAtom;
class EInde;
class EQCon;
class EFunC;
class EStPP;
class EStPA;
class EInEP;
class EDeEM;
class EDere;
class EInPE;
class EDeME;
class ENega;
class EMult;
class EDivi;
class ERema;
class EAddi;
class ESubt;
class ELShi;
class ERShi;
class ECoSm;
class ECoGr;
class ECoSE;
class ECoGE;
class EInEq;
class EEqua;
class EConj;
class EDisj;
class EAssi;
class EAsPl;
class EAsMi;
class ECond;
class EExce;
class TInt;
class TBool;
class TDouble;
class TVoid;
class TString;
class LString;
class LInt;
class ListArg;
class ListStm;
class ListId;
class ListType;
class ListExp;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitDef(Def *p) = 0;
  virtual void visitStm(Stm *p) = 0;
  virtual void visitArg(Arg *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitLit(Lit *p) = 0;
  virtual void visitFunc(Func *p) = 0;
  virtual void visitSDecl(SDecl *p) = 0;
  virtual void visitSDecls(SDecls *p) = 0;
  virtual void visitSInit(SInit *p) = 0;
  virtual void visitSReturn(SReturn *p) = 0;
  virtual void visitSWhile(SWhile *p) = 0;
  virtual void visitSDo(SDo *p) = 0;
  virtual void visitSFor(SFor *p) = 0;
  virtual void visitSIf(SIf *p) = 0;
  virtual void visitSIfElse(SIfElse *p) = 0;
  virtual void visitSBlock(SBlock *p) = 0;
  virtual void visitSTypedef(STypedef *p) = 0;
  virtual void visitSStruct(SStruct *p) = 0;
  virtual void visitTemplateInstantiations(TemplateInstantiations *p) = 0;
  virtual void visitQualifiedConstants(QualifiedConstants *p) = 0;
  virtual void visitStatementDefinition(StatementDefinition *p) = 0;
  virtual void visitArgumentDefinition(ArgumentDefinition *p) = 0;
  virtual void visitEAtom(EAtom *p) = 0;
  virtual void visitEInde(EInde *p) = 0;
  virtual void visitEQCon(EQCon *p) = 0;
  virtual void visitEFunC(EFunC *p) = 0;
  virtual void visitEStPP(EStPP *p) = 0;
  virtual void visitEStPA(EStPA *p) = 0;
  virtual void visitEInEP(EInEP *p) = 0;
  virtual void visitEDeEM(EDeEM *p) = 0;
  virtual void visitEDere(EDere *p) = 0;
  virtual void visitEInPE(EInPE *p) = 0;
  virtual void visitEDeME(EDeME *p) = 0;
  virtual void visitENega(ENega *p) = 0;
  virtual void visitEMult(EMult *p) = 0;
  virtual void visitEDivi(EDivi *p) = 0;
  virtual void visitERema(ERema *p) = 0;
  virtual void visitEAddi(EAddi *p) = 0;
  virtual void visitESubt(ESubt *p) = 0;
  virtual void visitELShi(ELShi *p) = 0;
  virtual void visitERShi(ERShi *p) = 0;
  virtual void visitECoSm(ECoSm *p) = 0;
  virtual void visitECoGr(ECoGr *p) = 0;
  virtual void visitECoSE(ECoSE *p) = 0;
  virtual void visitECoGE(ECoGE *p) = 0;
  virtual void visitEInEq(EInEq *p) = 0;
  virtual void visitEEqua(EEqua *p) = 0;
  virtual void visitEConj(EConj *p) = 0;
  virtual void visitEDisj(EDisj *p) = 0;
  virtual void visitEAssi(EAssi *p) = 0;
  virtual void visitEAsPl(EAsPl *p) = 0;
  virtual void visitEAsMi(EAsMi *p) = 0;
  virtual void visitECond(ECond *p) = 0;
  virtual void visitEExce(EExce *p) = 0;
  virtual void visitTInt(TInt *p) = 0;
  virtual void visitTBool(TBool *p) = 0;
  virtual void visitTDouble(TDouble *p) = 0;
  virtual void visitTVoid(TVoid *p) = 0;
  virtual void visitTString(TString *p) = 0;
  virtual void visitLString(LString *p) = 0;
  virtual void visitLInt(LInt *p) = 0;
  virtual void visitListArg(ListArg *p) = 0;
  virtual void visitListStm(ListStm *p) = 0;
  virtual void visitListId(ListId *p) = 0;
  virtual void visitListType(ListType *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitId(Id x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Def : public Visitable
{
public:
  virtual Def *clone() const = 0;

};

class Stm : public Visitable
{
public:
  virtual Stm *clone() const = 0;

};

class Arg : public Visitable
{
public:
  virtual Arg *clone() const = 0;

};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};

class Lit : public Visitable
{
public:
  virtual Lit *clone() const = 0;

};



class Func : public Def
{
public:
  Type *type_;
  Id id_;
  ListArg *listarg_;
  ListStm *liststm_;

  Func(const Func &);
  Func &operator=(const Func &);
  Func(Type *p1, Id p2, ListArg *p3, ListStm *p4);
  ~Func();
  virtual void accept(Visitor *v);
  virtual Func *clone() const;
  void swap(Func &);
};

class SDecl : public Stm
{
public:
  Type *type_;
  Id id_;

  SDecl(const SDecl &);
  SDecl &operator=(const SDecl &);
  SDecl(Type *p1, Id p2);
  ~SDecl();
  virtual void accept(Visitor *v);
  virtual SDecl *clone() const;
  void swap(SDecl &);
};

class SDecls : public Stm
{
public:
  Type *type_;
  Id id_;
  ListId *listid_;

  SDecls(const SDecls &);
  SDecls &operator=(const SDecls &);
  SDecls(Type *p1, Id p2, ListId *p3);
  ~SDecls();
  virtual void accept(Visitor *v);
  virtual SDecls *clone() const;
  void swap(SDecls &);
};

class SInit : public Stm
{
public:
  Type *type_;
  Id id_;
  Exp *exp_;

  SInit(const SInit &);
  SInit &operator=(const SInit &);
  SInit(Type *p1, Id p2, Exp *p3);
  ~SInit();
  virtual void accept(Visitor *v);
  virtual SInit *clone() const;
  void swap(SInit &);
};

class SReturn : public Stm
{
public:
  Exp *exp_;

  SReturn(const SReturn &);
  SReturn &operator=(const SReturn &);
  SReturn(Exp *p1);
  ~SReturn();
  virtual void accept(Visitor *v);
  virtual SReturn *clone() const;
  void swap(SReturn &);
};

class SWhile : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  SWhile(const SWhile &);
  SWhile &operator=(const SWhile &);
  SWhile(Exp *p1, Stm *p2);
  ~SWhile();
  virtual void accept(Visitor *v);
  virtual SWhile *clone() const;
  void swap(SWhile &);
};

class SDo : public Stm
{
public:
  Stm *stm_;
  Exp *exp_;

  SDo(const SDo &);
  SDo &operator=(const SDo &);
  SDo(Stm *p1, Exp *p2);
  ~SDo();
  virtual void accept(Visitor *v);
  virtual SDo *clone() const;
  void swap(SDo &);
};

class SFor : public Stm
{
public:
  Type *type_;
  Id id_;
  Exp *exp_1;
  Exp *exp_2;
  Stm *stm_1;
  Stm *stm_2;

  SFor(const SFor &);
  SFor &operator=(const SFor &);
  SFor(Type *p1, Id p2, Exp *p3, Exp *p4, Stm *p5, Stm *p6);
  ~SFor();
  virtual void accept(Visitor *v);
  virtual SFor *clone() const;
  void swap(SFor &);
};

class SIf : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  SIf(const SIf &);
  SIf &operator=(const SIf &);
  SIf(Exp *p1, Stm *p2);
  ~SIf();
  virtual void accept(Visitor *v);
  virtual SIf *clone() const;
  void swap(SIf &);
};

class SIfElse : public Stm
{
public:
  Exp *exp_;
  Stm *stm_1;
  Stm *stm_2;

  SIfElse(const SIfElse &);
  SIfElse &operator=(const SIfElse &);
  SIfElse(Exp *p1, Stm *p2, Stm *p3);
  ~SIfElse();
  virtual void accept(Visitor *v);
  virtual SIfElse *clone() const;
  void swap(SIfElse &);
};

class SBlock : public Stm
{
public:
  ListStm *liststm_;

  SBlock(const SBlock &);
  SBlock &operator=(const SBlock &);
  SBlock(ListStm *p1);
  ~SBlock();
  virtual void accept(Visitor *v);
  virtual SBlock *clone() const;
  void swap(SBlock &);
};

class STypedef : public Stm
{
public:
  Type *type_1;
  Type *type_2;
  Id id_;

  STypedef(const STypedef &);
  STypedef &operator=(const STypedef &);
  STypedef(Type *p1, Type *p2, Id p3);
  ~STypedef();
  virtual void accept(Visitor *v);
  virtual STypedef *clone() const;
  void swap(STypedef &);
};

class SStruct : public Stm
{
public:
  Id id_;
  ListStm *liststm_;

  SStruct(const SStruct &);
  SStruct &operator=(const SStruct &);
  SStruct(Id p1, ListStm *p2);
  ~SStruct();
  virtual void accept(Visitor *v);
  virtual SStruct *clone() const;
  void swap(SStruct &);
};

class TemplateInstantiations : public Stm
{
public:
  ListType *listtype_;

  TemplateInstantiations(const TemplateInstantiations &);
  TemplateInstantiations &operator=(const TemplateInstantiations &);
  TemplateInstantiations(ListType *p1);
  ~TemplateInstantiations();
  virtual void accept(Visitor *v);
  virtual TemplateInstantiations *clone() const;
  void swap(TemplateInstantiations &);
};

class QualifiedConstants : public Stm
{
public:
  Id id_;
  ListId *listid_;

  QualifiedConstants(const QualifiedConstants &);
  QualifiedConstants &operator=(const QualifiedConstants &);
  QualifiedConstants(Id p1, ListId *p2);
  ~QualifiedConstants();
  virtual void accept(Visitor *v);
  virtual QualifiedConstants *clone() const;
  void swap(QualifiedConstants &);
};

class StatementDefinition : public Stm
{
public:
  Exp *exp_;

  StatementDefinition(const StatementDefinition &);
  StatementDefinition &operator=(const StatementDefinition &);
  StatementDefinition(Exp *p1);
  ~StatementDefinition();
  virtual void accept(Visitor *v);
  virtual StatementDefinition *clone() const;
  void swap(StatementDefinition &);
};

class ArgumentDefinition : public Arg
{
public:
  Exp *exp_;

  ArgumentDefinition(const ArgumentDefinition &);
  ArgumentDefinition &operator=(const ArgumentDefinition &);
  ArgumentDefinition(Exp *p1);
  ~ArgumentDefinition();
  virtual void accept(Visitor *v);
  virtual ArgumentDefinition *clone() const;
  void swap(ArgumentDefinition &);
};

class TInt : public Type
{
public:

  TInt(const TInt &);
  TInt &operator=(const TInt &);
  TInt();
  ~TInt();
  virtual void accept(Visitor *v);
  virtual TInt *clone() const;
  void swap(TInt &);
};

class TBool : public Type
{
public:

  TBool(const TBool &);
  TBool &operator=(const TBool &);
  TBool();
  ~TBool();
  virtual void accept(Visitor *v);
  virtual TBool *clone() const;
  void swap(TBool &);
};

class TDouble : public Type
{
public:

  TDouble(const TDouble &);
  TDouble &operator=(const TDouble &);
  TDouble();
  ~TDouble();
  virtual void accept(Visitor *v);
  virtual TDouble *clone() const;
  void swap(TDouble &);
};

class TVoid : public Type
{
public:

  TVoid(const TVoid &);
  TVoid &operator=(const TVoid &);
  TVoid();
  ~TVoid();
  virtual void accept(Visitor *v);
  virtual TVoid *clone() const;
  void swap(TVoid &);
};

class TString : public Type
{
public:

  TString(const TString &);
  TString &operator=(const TString &);
  TString();
  ~TString();
  virtual void accept(Visitor *v);
  virtual TString *clone() const;
  void swap(TString &);
};

class LString : public Lit
{
public:

  LString(const LString &);
  LString &operator=(const LString &);
  LString();
  ~LString();
  virtual void accept(Visitor *v);
  virtual LString *clone() const;
  void swap(LString &);
};

class LInt : public Lit
{
public:

  LInt(const LInt &);
  LInt &operator=(const LInt &);
  LInt();
  ~LInt();
  virtual void accept(Visitor *v);
  virtual LInt *clone() const;
  void swap(LInt &);
};

class EAtom : public Exp
{
public:
  Lit *lit_;

  EAtom(const EAtom &);
  EAtom &operator=(const EAtom &);
  EAtom(Lit *p1);
  ~EAtom();
  virtual void accept(Visitor *v);
  virtual EAtom *clone() const;
  void swap(EAtom &);
};

class EInde : public Exp
{
public:
  Exp *exp_;
  Id id_;

  EInde(const EInde &);
  EInde &operator=(const EInde &);
  EInde(Exp *p1, Id p2);
  ~EInde();
  virtual void accept(Visitor *v);
  virtual EInde *clone() const;
  void swap(EInde &);
};

class EQCon : public Exp
{
public:
  Exp *exp_;
  Id id_;

  EQCon(const EQCon &);
  EQCon &operator=(const EQCon &);
  EQCon(Exp *p1, Id p2);
  ~EQCon();
  virtual void accept(Visitor *v);
  virtual EQCon *clone() const;
  void swap(EQCon &);
};

class EFunC : public Exp
{
public:
  Exp *exp_;
  ListExp *listexp_;

  EFunC(const EFunC &);
  EFunC &operator=(const EFunC &);
  EFunC(Exp *p1, ListExp *p2);
  ~EFunC();
  virtual void accept(Visitor *v);
  virtual EFunC *clone() const;
  void swap(EFunC &);
};

class EStPP : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EStPP(const EStPP &);
  EStPP &operator=(const EStPP &);
  EStPP(Exp *p1, Exp *p2);
  ~EStPP();
  virtual void accept(Visitor *v);
  virtual EStPP *clone() const;
  void swap(EStPP &);
};

class EStPA : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EStPA(const EStPA &);
  EStPA &operator=(const EStPA &);
  EStPA(Exp *p1, Exp *p2);
  ~EStPA();
  virtual void accept(Visitor *v);
  virtual EStPA *clone() const;
  void swap(EStPA &);
};

class EInEP : public Exp
{
public:
  Exp *exp_;

  EInEP(const EInEP &);
  EInEP &operator=(const EInEP &);
  EInEP(Exp *p1);
  ~EInEP();
  virtual void accept(Visitor *v);
  virtual EInEP *clone() const;
  void swap(EInEP &);
};

class EDeEM : public Exp
{
public:
  Exp *exp_;

  EDeEM(const EDeEM &);
  EDeEM &operator=(const EDeEM &);
  EDeEM(Exp *p1);
  ~EDeEM();
  virtual void accept(Visitor *v);
  virtual EDeEM *clone() const;
  void swap(EDeEM &);
};

class EDere : public Exp
{
public:
  Exp *exp_;

  EDere(const EDere &);
  EDere &operator=(const EDere &);
  EDere(Exp *p1);
  ~EDere();
  virtual void accept(Visitor *v);
  virtual EDere *clone() const;
  void swap(EDere &);
};

class EInPE : public Exp
{
public:
  Exp *exp_;

  EInPE(const EInPE &);
  EInPE &operator=(const EInPE &);
  EInPE(Exp *p1);
  ~EInPE();
  virtual void accept(Visitor *v);
  virtual EInPE *clone() const;
  void swap(EInPE &);
};

class EDeME : public Exp
{
public:
  Exp *exp_;

  EDeME(const EDeME &);
  EDeME &operator=(const EDeME &);
  EDeME(Exp *p1);
  ~EDeME();
  virtual void accept(Visitor *v);
  virtual EDeME *clone() const;
  void swap(EDeME &);
};

class ENega : public Exp
{
public:
  Exp *exp_;

  ENega(const ENega &);
  ENega &operator=(const ENega &);
  ENega(Exp *p1);
  ~ENega();
  virtual void accept(Visitor *v);
  virtual ENega *clone() const;
  void swap(ENega &);
};

class EMult : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMult(const EMult &);
  EMult &operator=(const EMult &);
  EMult(Exp *p1, Exp *p2);
  ~EMult();
  virtual void accept(Visitor *v);
  virtual EMult *clone() const;
  void swap(EMult &);
};

class EDivi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDivi(const EDivi &);
  EDivi &operator=(const EDivi &);
  EDivi(Exp *p1, Exp *p2);
  ~EDivi();
  virtual void accept(Visitor *v);
  virtual EDivi *clone() const;
  void swap(EDivi &);
};

class ERema : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ERema(const ERema &);
  ERema &operator=(const ERema &);
  ERema(Exp *p1, Exp *p2);
  ~ERema();
  virtual void accept(Visitor *v);
  virtual ERema *clone() const;
  void swap(ERema &);
};

class EAddi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAddi(const EAddi &);
  EAddi &operator=(const EAddi &);
  EAddi(Exp *p1, Exp *p2);
  ~EAddi();
  virtual void accept(Visitor *v);
  virtual EAddi *clone() const;
  void swap(EAddi &);
};

class ESubt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ESubt(const ESubt &);
  ESubt &operator=(const ESubt &);
  ESubt(Exp *p1, Exp *p2);
  ~ESubt();
  virtual void accept(Visitor *v);
  virtual ESubt *clone() const;
  void swap(ESubt &);
};

class ELShi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELShi(const ELShi &);
  ELShi &operator=(const ELShi &);
  ELShi(Exp *p1, Exp *p2);
  ~ELShi();
  virtual void accept(Visitor *v);
  virtual ELShi *clone() const;
  void swap(ELShi &);
};

class ERShi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ERShi(const ERShi &);
  ERShi &operator=(const ERShi &);
  ERShi(Exp *p1, Exp *p2);
  ~ERShi();
  virtual void accept(Visitor *v);
  virtual ERShi *clone() const;
  void swap(ERShi &);
};

class ECoSm : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ECoSm(const ECoSm &);
  ECoSm &operator=(const ECoSm &);
  ECoSm(Exp *p1, Exp *p2);
  ~ECoSm();
  virtual void accept(Visitor *v);
  virtual ECoSm *clone() const;
  void swap(ECoSm &);
};

class ECoGr : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ECoGr(const ECoGr &);
  ECoGr &operator=(const ECoGr &);
  ECoGr(Exp *p1, Exp *p2);
  ~ECoGr();
  virtual void accept(Visitor *v);
  virtual ECoGr *clone() const;
  void swap(ECoGr &);
};

class ECoSE : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ECoSE(const ECoSE &);
  ECoSE &operator=(const ECoSE &);
  ECoSE(Exp *p1, Exp *p2);
  ~ECoSE();
  virtual void accept(Visitor *v);
  virtual ECoSE *clone() const;
  void swap(ECoSE &);
};

class ECoGE : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ECoGE(const ECoGE &);
  ECoGE &operator=(const ECoGE &);
  ECoGE(Exp *p1, Exp *p2);
  ~ECoGE();
  virtual void accept(Visitor *v);
  virtual ECoGE *clone() const;
  void swap(ECoGE &);
};

class EInEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EInEq(const EInEq &);
  EInEq &operator=(const EInEq &);
  EInEq(Exp *p1, Exp *p2);
  ~EInEq();
  virtual void accept(Visitor *v);
  virtual EInEq *clone() const;
  void swap(EInEq &);
};

class EEqua : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EEqua(const EEqua &);
  EEqua &operator=(const EEqua &);
  EEqua(Exp *p1, Exp *p2);
  ~EEqua();
  virtual void accept(Visitor *v);
  virtual EEqua *clone() const;
  void swap(EEqua &);
};

class EConj : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EConj(const EConj &);
  EConj &operator=(const EConj &);
  EConj(Exp *p1, Exp *p2);
  ~EConj();
  virtual void accept(Visitor *v);
  virtual EConj *clone() const;
  void swap(EConj &);
};

class EDisj : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDisj(const EDisj &);
  EDisj &operator=(const EDisj &);
  EDisj(Exp *p1, Exp *p2);
  ~EDisj();
  virtual void accept(Visitor *v);
  virtual EDisj *clone() const;
  void swap(EDisj &);
};

class EAssi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAssi(const EAssi &);
  EAssi &operator=(const EAssi &);
  EAssi(Exp *p1, Exp *p2);
  ~EAssi();
  virtual void accept(Visitor *v);
  virtual EAssi *clone() const;
  void swap(EAssi &);
};

class EAsPl : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAsPl(const EAsPl &);
  EAsPl &operator=(const EAsPl &);
  EAsPl(Exp *p1, Exp *p2);
  ~EAsPl();
  virtual void accept(Visitor *v);
  virtual EAsPl *clone() const;
  void swap(EAsPl &);
};

class EAsMi : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAsMi(const EAsMi &);
  EAsMi &operator=(const EAsMi &);
  EAsMi(Exp *p1, Exp *p2);
  ~EAsMi();
  virtual void accept(Visitor *v);
  virtual EAsMi *clone() const;
  void swap(EAsMi &);
};

class ECond : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;
  Exp *exp_3;

  ECond(const ECond &);
  ECond &operator=(const ECond &);
  ECond(Exp *p1, Exp *p2, Exp *p3);
  ~ECond();
  virtual void accept(Visitor *v);
  virtual ECond *clone() const;
  void swap(ECond &);
};

class EExce : public Exp
{
public:
  Exp *exp_;

  EExce(const EExce &);
  EExce &operator=(const EExce &);
  EExce(Exp *p1);
  ~EExce();
  virtual void accept(Visitor *v);
  virtual EExce *clone() const;
  void swap(EExce &);
};



class ListArg : public Visitable, public std::vector<Arg*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListArg *clone() const;
};

class ListStm : public Visitable, public std::vector<Stm*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStm *clone() const;
};

class ListId : public Visitable, public std::vector<Id>
{
public:
  virtual void accept(Visitor *v);
  virtual ListId *clone() const;
};

class ListType : public Visitable, public std::vector<Type*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListType *clone() const;
};

class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};



#endif
